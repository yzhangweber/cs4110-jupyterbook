Traceback (most recent call last):
  File "D:\Python313\Lib\site-packages\jupyter_core\utils\__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
    ~~~~~~~~~~~~~~~~~~~~~~~~^^
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "D:\Python313\Lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
    ~~~~~~~~~^
        nb,
        ^^^
    ...<4 lines>...
        **kwargs,
        ^^^^^^^^^
    )
    ^
  File "D:\Python313\Lib\site-packages\nbclient\client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
  File "D:\Python313\Lib\site-packages\jupyter_core\utils\__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^
  File "D:\Python313\Lib\asyncio\base_events.py", line 725, in run_until_complete
    return future.result()
           ~~~~~~~~~~~~~^^
  File "D:\Python313\Lib\site-packages\nbclient\client.py", line 709, in async_execute
    await self.async_execute_cell(
        cell, index, execution_count=self.code_cells_executed + 1
    )
  File "D:\Python313\Lib\site-packages\nbclient\client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "D:\Python313\Lib\site-packages\nbclient\client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
class ALANAnalyzer:
    def __init__(self):
        self.cwl_validator = CWLValidator()
        self.tm_decoder = TuringMachineDecoder()
        self.tm_decoder.debug = True
    
    def analyze_alan_membership(self, cwl_string):
        """Determine if a CWL string belongs to ALAN"""
        print(f"\nAnalyzing ALAN membership for: {cwl_string[:30]}...")
        print("=" * 60)
        
        # Step 1: Verify it's in CWL
        if not self.cwl_validator.is_valid_cwl(cwl_string):
            print("âœ— Not in CWL, therefore not in ALAN")
            return False, "not_cwl"
        
        print("âœ“ String is in CWL")
        
        # Step 2: Try to decode as a TM
        try:
            transitions = self.tm_decoder.decode_complete_machine(cwl_string)
            print(f"âœ“ Successfully decoded {len(transitions)} transitions")
        except Exception as e:
            print(f"âœ“ String is in ALAN (Reason: Invalid TM encoding - {e})")
            return True, "invalid_tm"
        
        # Step 3: Check if it represents a valid TM
        validity_issues = self.check_tm_validity(transitions)
        if validity_issues:
            print(f"âœ“ String is in ALAN (Reason: {validity_issues[0]})")
            return True, validity_issues[0]
        
        print("âœ“ Represents a valid TM")
        
        # Step 4: Simulate the TM on its own encoding
        accepts_self = self.simulate_tm_on_self(transitions, cwl_string)
        
        if accepts_self:
            print("âœ— TM accepts its own encoding - NOT in ALAN")
            return False, "accepts_self"
        else:
            print("âœ“ TM does not accept its own encoding - IS in ALAN")
            return True, "rejects_self"
    
    def check_tm_validity(self, transitions):
        """Check if transitions form a valid TM"""
        issues = []
        
        # Extract states
        states = set()
        for t in transitions:
            states.add(t['from'])
            states.add(t['to'])
        
        # Check for start state
        if 1 not in states:
            issues.append("missing_start_state")
        
        # Check for halt state
        if 2 not in states:
            issues.append("missing_halt_state")
        
        # Check for unreachable halt state
        if 2 in states and not any(t['to'] == 2 for t in transitions):
            issues.append("unreachable_halt_state")
        
        # Check for duplicate transitions
        transition_keys = [(t['from'], t['read']) for t in transitions]
        if len(transition_keys) != len(set(transition_keys)):
            issues.append("duplicate_transitions")
        
        return issues
    
    def simulate_tm_on_self(self, transitions, input_string):
        """Simulate the TM on its own encoding"""
        print("\nSimulating TM on its own encoding...")
        
        # Build transition table
        trans_dict = {}
        for t in transitions:
            trans_dict[(t['from'], t['read'])] = (t['to'], t['write'], t['move'])
        
        # Initialize simulation
        tape = list(input_string) + ['Î”'] * 1000
        head = 0
        state = 1  # Start state
        steps = 0
        max_steps = 10000
        
        while steps < max_steps:
            # Check if we've reached halt state
            if state == 2:
                print(f"  Reached halt state after {steps} steps")
                return True
            
            # Read current symbol
            current_symbol = tape[head] if head < len(tape) else 'Î”'
            
            # Find transition
            key = (state, current_symbol)
            if key not in trans_dict:
                print(f"  No transition for ({state}, '{current_symbol}') - rejecting")
                return False
            
            next_state, write_symbol, direction = trans_dict[key]
            
            # Execute transition
            tape[head] = write_symbol
            state = next_state
            
            if direction == 'L' and head > 0:
                head -= 1
            elif direction == 'R':
                head += 1
            
            steps += 1
        
        print(f"  Exceeded max steps ({max_steps}) - rejecting")
        return False

alan_analyzer = ALANAnalyzer()
------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[4][39m[32m, line 121[39m
[32m    118[39m         [38;5;28mprint[39m([33mf[39m[33m"[39m[33m  Exceeded max steps ([39m[38;5;132;01m{[39;00mmax_steps[38;5;132;01m}[39;00m[33m) - rejecting[39m[33m"[39m)
[32m    119[39m         [38;5;28;01mreturn[39;00m [38;5;28;01mFalse[39;00m
[32m--> [39m[32m121[39m alan_analyzer = [43mALANAnalyzer[49m[43m([49m[43m)[49m

[36mCell[39m[36m [39m[32mIn[4][39m[32m, line 4[39m, in [36mALANAnalyzer.__init__[39m[34m(self)[39m
[32m      2[39m [38;5;28;01mdef[39;00m[38;5;250m [39m[34m__init__[39m([38;5;28mself[39m):
[32m      3[39m     [38;5;28mself[39m.cwl_validator = CWLValidator()
[32m----> [39m[32m4[39m     [38;5;28mself[39m.tm_decoder = [43mTuringMachineDecoder[49m()
[32m      5[39m     [38;5;28mself[39m.tm_decoder.debug = [38;5;28;01mTrue[39;00m

[31mNameError[39m: name 'TuringMachineDecoder' is not defined

