
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The Universal Turing Machine &#8212; Decode Computation:Hands-On Formal Languages and Algorithms</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'content - backup/Part_3_Turing_Machines/Chapter_16/Chapter16_Universal_Turing_Machine';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Decode Computation:Hands-On Formal Languages and Algorithms - Home"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Decode Computation:Hands-On Formal Languages and Algorithms - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    Decode Computation︰ Hands-On Formal Languages and Algorithms
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Regular Languages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_1_Regular_Languages/Chapter01_Languages.html">1. Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_1_Regular_Languages/Chapter02_Regular_Expressions.html">2. Regular Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_1_Regular_Languages/Chapter03_Finite_Automata.html">3. Finite Automata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_1_Regular_Languages/Chapter04_Nondeterministic_Finite_Automata.html">4. Nondeterministic Finite Automata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_1_Regular_Languages/Chapter05_Nonregular_Languages.html">5. Nonregular Languages</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Context Free Languages</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_2_Context_Free_Languages/Chapter_08/Chapter08_Fundamentals_of_CFG.html">6. Fundamentals of Context-Free Grammar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_2_Context_Free_Languages/Chapter_09/Chapter09_CFG_Normal_Forms_and_Transformations.html">7. Normal Forms and Transformations in Context-Free Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_2_Context_Free_Languages/Chapter_10/Chapter10_PDA.html">8. Pushdown Automata (PDA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_2_Context_Free_Languages/Chapter_11/Chapter11_Properties_of_Context_free%20Languages.html">9. Properties of Context-free Languages (CFL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_2_Context_Free_Languages/Chapter_12/Chapter12_Decidability_in_CFG.html">10. Decidability in Context-Free Grammars (CFGs)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Turing Machines</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_3_Turing_Machines/Chapter_13/Chapter13_Introduction_to_Turing_Machines.html">11. Introduction to Turing Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_3_Turing_Machines/Chapter_14/Chapter14_Turing_Machine_Languages.html">12. Turing Machine Languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_3_Turing_Machines/Chapter_15/Chapter15_Turing_Machine_Encoding.html">13. Turing Machine Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_3_Turing_Machines/Chapter_16/Chapter16_Universal_Turing_Machine.html">14. The Universal Turing Machine</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Advanced Topics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_4_Advanced_Topics/Chapter17_P_and_NP_Problems.html">15. P and NP Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../content/Part_4_Advanced_Topics/Chapter18_NP_Completeness.html">16. NP-Completeness</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fcontent - backup/Part_3_Turing_Machines/Chapter_16/Chapter16_Universal_Turing_Machine.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/content - backup/Part_3_Turing_Machines/Chapter_16/Chapter16_Universal_Turing_Machine.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>The Universal Turing Machine</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turing-machine-subprograms-insert-and-delete">1. Turing Machine Subprograms: insert and delete</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-challenge-of-insert-and-delete">1.1 The Challenge of Insert and Delete</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#insert">1.2 Insert</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#delete">1.3 Delete</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-python-implementation">1.4 Example Python Implementation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">2. The Universal Turing Machine</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definition-of-the-universal-turing-machine">2.1 Definition of The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-study-the-universal-turing-machine">2.2 Why Study The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-world-applications-of-the-universal-turing-machine">2.3 Real-World Applications of The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-the-utm-exists">2.4 Why the UTM Exists</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-to-construct-the-utm">2.5 How to Construct the UTM</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1-design-the-encoding-scheme">2.5.1 Step 1: Design the Encoding Scheme</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2-design-the-utm-s-tape-layout">2.5.2 Step 2: Design the UTM’s Tape Layout</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3-design-the-utm-s-state-structure">2.5.3 Step 3: Design the UTM’s State Structure</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">2.5.4 Example Python Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-halting-problem">3. The Halting Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-halting-problem-is-undecidable">3.1 The Halting Problem is Undecidable</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-collatz-conjecture-and-halting-behavior">3.2 The Collatz Conjecture and Halting Behavior</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-utm-and-the-halting-problem">3.3 The UTM and the Halting Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implications">3.4 Practical Implications</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#software-verification">3.4.1 Software Verification</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#compiler-optimization">3.4.2 Compiler Optimization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#malware-detection">3.4.3 Malware Detection</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#program-equivalence">3.4.4 Program Equivalence</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#resource-usage">3.4.5 Resource Usage</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#verification-of-ai-safety">3.4.6 Verification of AI Safety</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">3.5 Example Python Implementation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-undecidable-problems">4. Other Undecidable Problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rices-theorem">4.1 Rice’s Theorem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#post-correspondence-problem-pcp">4.2 Post Correspondence Problem (PCP)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tiling-problem">4.3 Tiling Problem</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-exercises">5. Practice Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1">5.1 Exercise 1:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2">5.2 Exercise 2:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-rices-theorem-in-action">5.3 Exercise 3: Rice’s Theorem in Action</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-try-a-reduction-argument">5.4 Exercise 4: Try a Reduction Argument</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">6. Further Reading</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="the-universal-turing-machine">
<h1>The Universal Turing Machine<a class="headerlink" href="#the-universal-turing-machine" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>This notebook introduces key concepts in the theory of computation: Turing Machine subprograms, the Universal Turing Machine, and the Halting Problem. We begin by examining Turing Machine subprograms: modular sequences of transitions used to perform basic tasks such as inserting or deleting symbols, which serve as building blocks for more complex machines. Next, we explore how the Universal Turing Machine (UTM) can simulate any other Turing machine by interpreting encoded descriptions of both the machine and its input. Finally, we discuss the Halting Problem, a fundamental result that shows there is no general algorithm capable of determining whether a Turing machine halts on a given input. Together, these topics highlight both the expressive power and inherent limits of computation.</p>
<p>The following are example Python implementations of a Turing Machine, provided as starter code for use in other Python code examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Turing Machine Encoder</span>
<span class="sd">Encodes a Turing machine into a string representation using &#39;a&#39; and &#39;b&#39; symbols</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TuringMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a Turing Machine with states, symbols, and transitions&quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">,</span> <span class="n">tape_alphabet</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">start_state</span><span class="p">,</span> <span class="n">halt_states</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Turing Machine</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            states: List of state names (will be converted to numbers)</span>
<span class="sd">            alphabet: Input alphabet</span>
<span class="sd">            tape_alphabet: Complete tape alphabet (includes blank symbol)</span>
<span class="sd">            transitions: Dict of (state, symbol) -&gt; (new_state, write_symbol, direction)</span>
<span class="sd">            start_state: Name of the start state</span>
<span class="sd">            halt_states: List of halt state names (can be single state or list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">alphabet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tape_alphabet</span> <span class="o">=</span> <span class="n">tape_alphabet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="n">transitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span> <span class="o">=</span> <span class="n">start_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">halt_states</span> <span class="o">=</span> <span class="n">halt_states</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">halt_states</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">halt_states</span><span class="p">]</span>
        
        <span class="c1"># Create state mapping following convention</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_state_mapping</span><span class="p">()</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_state_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create numeric mapping for states following convention:</span>
<span class="sd">        1 = start state</span>
<span class="sd">        2 = halt state(s)</span>
<span class="sd">        3+ = other states</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Start state is always 1</span>
        <span class="n">mapping</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># Halt states are all mapped to 2</span>
        <span class="k">for</span> <span class="n">halt_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">halt_states</span><span class="p">:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">halt_state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        
        <span class="c1"># Other states get 3, 4, 5, ...</span>
        <span class="n">state_num</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_num</span>
                <span class="n">state_num</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">mapping</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">display_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display information about the Turing Machine&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Turing Machine Configuration:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  States: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Start state: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Halt state(s): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">halt_states</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Input alphabet: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alphabet</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Tape alphabet: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tape_alphabet</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">State Mapping:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">role</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">role</span> <span class="o">=</span> <span class="s2">&quot; (START)&quot;</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">role</span> <span class="o">=</span> <span class="s2">&quot; (HALT)&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">num</span><span class="si">}{</span><span class="n">role</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of transitions: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TMEncoder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Encodes Turing Machines into &#39;a&#39; and &#39;b&#39; string representation&quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Symbol encoding table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_codes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;aa&#39;</span><span class="p">,</span>
            <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;ab&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Δ&#39;</span><span class="p">:</span> <span class="s1">&#39;ba&#39;</span><span class="p">,</span>  <span class="c1"># Blank symbol</span>
            <span class="s1">&#39;_&#39;</span><span class="p">:</span> <span class="s1">&#39;ba&#39;</span><span class="p">,</span>  <span class="c1"># Alternative blank notation</span>
            <span class="s1">&#39;#&#39;</span><span class="p">:</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span>  <span class="c1"># Special symbol</span>
            <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="s1">&#39;aaa&#39;</span><span class="p">,</span> <span class="c1"># For machines with larger alphabets</span>
            <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="s1">&#39;aab&#39;</span><span class="p">,</span>
            <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="s1">&#39;aba&#39;</span><span class="p">,</span>
            <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="s1">&#39;abb&#39;</span><span class="p">,</span>
            <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="s1">&#39;baa&#39;</span><span class="p">,</span>
            <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="s1">&#39;bab&#39;</span><span class="p">,</span>
            <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="s1">&#39;bba&#39;</span><span class="p">,</span>
            <span class="s1">&#39;7&#39;</span><span class="p">:</span> <span class="s1">&#39;bbb&#39;</span>
        <span class="p">}</span>
        
        <span class="c1"># Direction encoding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction_codes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
            <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="s1">&#39;ab&#39;</span>  <span class="c1"># Stay (if used)</span>
        <span class="p">}</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">encode_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_num</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode a state number as a^n b&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">state_num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;State must be a positive integer, got </span><span class="si">{</span><span class="n">state_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="n">state_num</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">encode_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode a tape symbol&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_codes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown symbol: </span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_codes</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">encode_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode a movement direction&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction_codes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown direction: </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction_codes</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">encode_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">read_sym</span><span class="p">,</span> <span class="n">write_sym</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode a single transition&quot;&quot;&quot;</span>
        <span class="n">encoded</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_state</span><span class="p">(</span><span class="n">from_state</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_state</span><span class="p">(</span><span class="n">to_state</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_symbol</span><span class="p">(</span><span class="n">read_sym</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_symbol</span><span class="p">(</span><span class="n">write_sym</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_direction</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">encoded</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">encode_tm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">use_lexicographic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode a complete Turing Machine</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tm: TuringMachine object</span>
<span class="sd">            use_lexicographic: If True, sort transitions lexicographically</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Encoded string representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert transitions to use numeric states</span>
        <span class="n">numeric_transitions</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">),</span> <span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">write_symbol</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tm</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">from_num</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">state_mapping</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="n">to_num</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">state_mapping</span><span class="p">[</span><span class="n">next_state</span><span class="p">]</span>
            
            <span class="n">encoded_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_transition</span><span class="p">(</span>
                <span class="n">from_num</span><span class="p">,</span> <span class="n">to_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">write_symbol</span><span class="p">,</span> <span class="n">direction</span>
            <span class="p">)</span>
            
            <span class="n">numeric_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">from_num</span><span class="p">,</span>
                <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="n">to_num</span><span class="p">,</span>
                <span class="s1">&#39;read&#39;</span><span class="p">:</span> <span class="n">symbol</span><span class="p">,</span>
                <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="n">write_symbol</span><span class="p">,</span>
                <span class="s1">&#39;move&#39;</span><span class="p">:</span> <span class="n">direction</span><span class="p">,</span>
                <span class="s1">&#39;encoded&#39;</span><span class="p">:</span> <span class="n">encoded_trans</span>
            <span class="p">})</span>
        
        <span class="c1"># Sort lexicographically if requested</span>
        <span class="k">if</span> <span class="n">use_lexicographic</span><span class="p">:</span>
            <span class="n">numeric_transitions</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;encoded&#39;</span><span class="p">])</span>
        
        <span class="c1"># Concatenate all encodings</span>
        <span class="n">encoded_tm</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="s1">&#39;encoded&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="n">numeric_transitions</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">encoded_tm</span><span class="p">,</span> <span class="n">numeric_transitions</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">display_encoding_details</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">encoded_tm</span><span class="p">,</span> <span class="n">transitions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display detailed encoding information&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Encoding Details:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;From&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;To&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Read&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Write&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Move&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Encoding&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
            <span class="c1"># Find original state names</span>
            <span class="n">from_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tm</span><span class="o">.</span><span class="n">state_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">trans</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">to_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tm</span><span class="o">.</span><span class="n">state_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">trans</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">from_name</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">to_name</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">trans</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trans</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">trans</span><span class="p">[</span><span class="s1">&#39;move&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">trans</span><span class="p">[</span><span class="s1">&#39;encoded&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Complete Encoding (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">)</span><span class="si">}</span><span class="s2"> characters):&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">)</span>
        
        <span class="c1"># Show in colors for readability</span>
        <span class="c1"># TODO</span>


<span class="c1"># Example usage functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">example_simple_tm</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example: Simple TM that converts &#39;a&#39; to &#39;b&#39;&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 1: Simple TM that converts &#39;a&#39; to &#39;b&#39;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;q_halt&#39;</span><span class="p">]</span>
    <span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
    <span class="n">tape_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">]</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_halt&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q_scan&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q_halt&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">tm</span> <span class="o">=</span> <span class="n">TuringMachine</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">,</span> <span class="n">tape_alphabet</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="s1">&#39;q_start&#39;</span><span class="p">,</span> <span class="s1">&#39;q_halt&#39;</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">display_info</span><span class="p">()</span>
    
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">TMEncoder</span><span class="p">()</span>
    <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode_tm</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="n">display_encoding_details</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span>


<span class="k">def</span><span class="w"> </span><span class="nf">example_from_table</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example: TM from the provided table&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 2: TM from the provided transition table&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">]</span>
    <span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
    <span class="n">tape_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">]</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">tm</span> <span class="o">=</span> <span class="n">TuringMachine</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">,</span> <span class="n">tape_alphabet</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">display_info</span><span class="p">()</span>
    
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">TMEncoder</span><span class="p">()</span>
    <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode_tm</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="n">display_encoding_details</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span>


<span class="k">def</span><span class="w"> </span><span class="nf">example_binary_increment</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example: Binary increment TM&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 3: Binary Increment TM&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;qaccept&#39;</span><span class="p">]</span>
    <span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
    <span class="n">tape_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">]</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Move to rightmost digit</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        
        <span class="c1"># Add 1 with carry</span>
        <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        
        <span class="c1"># Move back to start</span>
        <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qaccept&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        
        <span class="c1"># Handle overflow</span>
        <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qaccept&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">tm</span> <span class="o">=</span> <span class="n">TuringMachine</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">,</span> <span class="n">tape_alphabet</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;qaccept&#39;</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">display_info</span><span class="p">()</span>
    
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">TMEncoder</span><span class="p">()</span>
    <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode_tm</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="n">display_encoding_details</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span><span class="p">,</span> <span class="n">trans_list</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">encoded</span>


<span class="k">def</span><span class="w"> </span><span class="nf">verify_encoding</span><span class="p">(</span><span class="n">encoded_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that an encoded string contains only &#39;a&#39; and &#39;b&#39;&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="s1">&#39;ab&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">encoded_string</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;String contains characters other than &#39;a&#39; and &#39;b&#39;&quot;</span>
    
    <span class="c1"># Check for basic structure</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded_string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Empty encoding&quot;</span>
    
    <span class="c1"># Could add more validation here</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Valid encoding&quot;</span>


<span class="c1"># Main execution</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Run examples</span>
    <span class="n">tm1</span><span class="p">,</span> <span class="n">enc1</span> <span class="o">=</span> <span class="n">example_simple_tm</span><span class="p">()</span>
    <span class="n">tm2</span><span class="p">,</span> <span class="n">enc2</span> <span class="o">=</span> <span class="n">example_from_table</span><span class="p">()</span>
    <span class="n">tm3</span><span class="p">,</span> <span class="n">enc3</span> <span class="o">=</span> <span class="n">example_binary_increment</span><span class="p">()</span>
    
    <span class="c1"># Verify encodings</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encoding Verification&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">enc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="n">tm1</span><span class="p">,</span> <span class="n">enc1</span><span class="p">),</span> <span class="p">(</span><span class="n">tm2</span><span class="p">,</span> <span class="n">enc2</span><span class="p">),</span> <span class="p">(</span><span class="n">tm3</span><span class="p">,</span> <span class="n">enc3</span><span class="p">)],</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">valid</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">verify_encoding</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span><span class="si">}</span><span class="s2"> characters&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;a&#39; count: </span><span class="si">{</span><span class="n">enc</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;b&#39; count: </span><span class="si">{</span><span class="n">enc</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Ratio a:b = </span><span class="si">{</span><span class="n">enc</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">enc</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">:1&quot;</span><span class="p">)</span>
    
    <span class="c1"># Interactive mode</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You can now create your own TM and encode it!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Modify the code above to define your own transitions.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>====================================================================================================
Example 1: Simple TM that converts &#39;a&#39; to &#39;b&#39;
====================================================================================================
Turing Machine Configuration:
  States: [&#39;q_start&#39;, &#39;q_scan&#39;, &#39;q_halt&#39;]
  Start state: q_start
  Halt state(s): [&#39;q_halt&#39;]
  Input alphabet: [&#39;a&#39;, &#39;b&#39;]
  Tape alphabet: [&#39;a&#39;, &#39;b&#39;, &#39;Δ&#39;]

State Mapping:
  q_start -&gt; 1 (START)
  q_halt -&gt; 2 (HALT)
  q_scan -&gt; 3

Number of transitions: 6

Encoding Details:
----------------------------------------------------------------------------------------------------
From       To         Read       Write      Move       Encoding                      
----------------------------------------------------------------------------------------------------
q_scan     q_scan     a          b          R          aaabaaabaaabb                 
q_scan     q_scan     b          b          R          aaabaaabababb                 
q_scan     q_halt     Δ          Δ          S          aaabaabbabaab                 
q_start    q_scan     a          b          R          abaaabaaabb                   
q_start    q_halt     Δ          Δ          S          abaabbabaab                   
q_start    q_start    b          b          R          ababababb                     
----------------------------------------------------------------------------------------------------

Complete Encoding (70 characters):
aaabaaabaaabbaaabaaabababbaaabaabbabaababaaabaaabbabaabbabaabababababb

====================================================================================================
Example 2: TM from the provided transition table
====================================================================================================
Turing Machine Configuration:
  States: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
  Start state: 1
  Halt state(s): [&#39;2&#39;]
  Input alphabet: [&#39;a&#39;, &#39;b&#39;]
  Tape alphabet: [&#39;a&#39;, &#39;b&#39;, &#39;Δ&#39;]

State Mapping:
  1 -&gt; 1 (START)
  2 -&gt; 2 (HALT)
  3 -&gt; 3

Number of transitions: 5

Encoding Details:
----------------------------------------------------------------------------------------------------
From       To         Read       Write      Move       Encoding                      
----------------------------------------------------------------------------------------------------
3          3          b          b          L          aaabaaabababa                 
3          2          Δ          b          L          aaabaabbaaba                  
1          3          b          a          R          abaaababaab                   
1          1          a          a          R          ababaaaab                     
1          1          Δ          Δ          R          ababbabab                     
----------------------------------------------------------------------------------------------------

Complete Encoding (54 characters):
aaabaaabababaaaabaabbaabaabaaababaabababaaaabababbabab

====================================================================================================
Example 3: Binary Increment TM
====================================================================================================
Turing Machine Configuration:
  States: [&#39;q0&#39;, &#39;q1&#39;, &#39;q2&#39;, &#39;q3&#39;, &#39;qaccept&#39;]
  Start state: q0
  Halt state(s): [&#39;qaccept&#39;]
  Input alphabet: [&#39;0&#39;, &#39;1&#39;]
  Tape alphabet: [&#39;0&#39;, &#39;1&#39;, &#39;Δ&#39;]

State Mapping:
  q0 -&gt; 1 (START)
  qaccept -&gt; 2 (HALT)
  q1 -&gt; 3
  q2 -&gt; 4
  q3 -&gt; 5

Number of transitions: 12

Encoding Details:
----------------------------------------------------------------------------------------------------
From       To         Read       Write      Move       Encoding                      
----------------------------------------------------------------------------------------------------
q3         q3         0          0          R          aaaaabaaaaabaaaaaab           
q3         q3         1          1          R          aaaaabaaaaabaabaabb           
q3         qaccept    Δ          Δ          S          aaaaabaabbabaab               
q2         q2         0          0          L          aaaabaaaabaaaaaaa             
q2         q2         1          1          L          aaaabaaaabaabaaba             
q2         qaccept    Δ          Δ          R          aaaabaabbabab                 
q1         q3         Δ          1          R          aaabaaaaabbaaabb              
q1         q2         0          1          L          aaabaaaabaaaaaba              
q1         q1         1          0          L          aaabaaabaabaaaa               
q0         q1         Δ          Δ          L          abaaabbabaa                   
q0         q0         0          0          R          ababaaaaaab                   
q0         q0         1          1          R          ababaabaabb                   
----------------------------------------------------------------------------------------------------

Complete Encoding (180 characters):
aaaaabaaaaabaaaaaabaaaaabaaaaabaabaabbaaaaabaabbabaabaaaabaaaabaaaaaaaaaaabaaaabaabaabaaaaabaabbababaaabaaaaabbaaabbaaabaaaabaaaaabaaaabaaabaabaaaaabaaabbabaaababaaaaaabababaabaabb

====================================================================================================
Encoding Verification
====================================================================================================
Example 1: Valid encoding
  Length: 70 characters
  &#39;a&#39; count: 42
  &#39;b&#39; count: 28
  Ratio a:b = 1.50:1
Example 2: Valid encoding
  Length: 54 characters
  &#39;a&#39; count: 34
  &#39;b&#39; count: 20
  Ratio a:b = 1.70:1
Example 3: Valid encoding
  Length: 180 characters
  &#39;a&#39; count: 133
  &#39;b&#39; count: 47
  Ratio a:b = 2.83:1

====================================================================================================
You can now create your own TM and encode it!
Modify the code above to define your own transitions.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">analyze_cwl_codeword</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Analyze the structure of a single CWL code word&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ANATOMY OF A CWL CODE WORD&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="c1"># Example transition: (1,a) → (3,b,R)</span>
    <span class="n">codeword</span> <span class="o">=</span> <span class="s2">&quot;abaaababbabb&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Example code word: </span><span class="si">{</span><span class="n">codeword</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Detailed breakdown:&quot;</span><span class="p">)</span>
    
    <span class="c1"># Parse the components</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># First state</span>
    <span class="n">state1_start</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="k">while</span> <span class="n">codeword</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Skip &#39;b&#39;</span>
    <span class="n">state1</span> <span class="o">=</span> <span class="n">codeword</span><span class="p">[</span><span class="n">state1_start</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Position </span><span class="si">{</span><span class="n">state1_start</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">: &#39;</span><span class="si">{</span><span class="n">state1</span><span class="si">}</span><span class="s2">&#39; = State </span><span class="si">{</span><span class="n">state1</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Second state</span>
    <span class="n">state2_start</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="k">while</span> <span class="n">codeword</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Skip &#39;b&#39;</span>
    <span class="n">state2</span> <span class="o">=</span> <span class="n">codeword</span><span class="p">[</span><span class="n">state2_start</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Position </span><span class="si">{</span><span class="n">state2_start</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">: &#39;</span><span class="si">{</span><span class="n">state2</span><span class="si">}</span><span class="s2">&#39; = State </span><span class="si">{</span><span class="n">state2</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Five-character block</span>
    <span class="n">five_chars</span> <span class="o">=</span> <span class="n">codeword</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Position </span><span class="si">{</span><span class="n">pos</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="o">+</span><span class="mi">4</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">: &#39;</span><span class="si">{</span><span class="n">five_chars</span><span class="si">}</span><span class="s2">&#39; = Symbol/Direction encoding&quot;</span><span class="p">)</span>
    
    <span class="c1"># Interpret the five characters</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  Five-character block interpretation:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Characters 1-2: &#39;</span><span class="si">{</span><span class="n">five_chars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; = Read symbol&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Characters 3-4: &#39;</span><span class="si">{</span><span class="n">five_chars</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; = Write symbol&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Character 5:    &#39;</span><span class="si">{</span><span class="n">five_chars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;  = Direction&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">codeword</span>

<span class="n">example_codeword</span> <span class="o">=</span> <span class="n">analyze_cwl_codeword</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ANATOMY OF A CWL CODE WORD
============================================================

Example code word: abaaababbabb

Detailed breakdown:
  Position  0- 1: &#39;ab&#39; = State 1
  Position  2- 5: &#39;aaab&#39; = State 3
  Position  6-10: &#39;abbab&#39; = Symbol/Direction encoding

  Five-character block interpretation:
    Characters 1-2: &#39;ab&#39; = Read symbol
    Characters 3-4: &#39;ba&#39; = Write symbol
    Character 5:    &#39;b&#39;  = Direction
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CWLValidator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Build the regex pattern for CWL</span>
        <span class="c1"># a+ means one or more &#39;a&#39;s</span>
        <span class="c1"># (a+b) means either &#39;a&#39; or &#39;b&#39;</span>
        <span class="c1"># {5} means exactly 5 occurrences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^(a+ba+b[ab]</span><span class="si">{5}</span><span class="s1">)*&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_cwl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cwl_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the provided string is a valid CWL word.</span>
<span class="sd">        Returns True if it matches the pattern, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">cwl_string</span><span class="p">))</span>        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ALANAnalyzer</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cwl_validator</span> <span class="o">=</span> <span class="n">CWLValidator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm_decoder</span> <span class="o">=</span> <span class="n">TuringMachineDecoder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm_decoder</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">analyze_alan_membership</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cwl_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if a CWL string belongs to ALAN&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Analyzing ALAN membership for: </span><span class="si">{</span><span class="n">cwl_string</span><span class="p">[:</span><span class="mi">30</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
        
        <span class="c1"># Step 1: Verify it&#39;s in CWL</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cwl_validator</span><span class="o">.</span><span class="n">is_valid_cwl</span><span class="p">(</span><span class="n">cwl_string</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✗ Not in CWL, therefore not in ALAN&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;not_cwl&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✓ String is in CWL&quot;</span><span class="p">)</span>
        
        <span class="c1"># Step 2: Try to decode as a TM</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_decoder</span><span class="o">.</span><span class="n">decode_complete_machine</span><span class="p">(</span><span class="n">cwl_string</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✓ Successfully decoded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">transitions</span><span class="p">)</span><span class="si">}</span><span class="s2"> transitions&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✓ String is in ALAN (Reason: Invalid TM encoding - </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;invalid_tm&quot;</span>
        
        <span class="c1"># Step 3: Check if it represents a valid TM</span>
        <span class="n">validity_issues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_tm_validity</span><span class="p">(</span><span class="n">transitions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">validity_issues</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✓ String is in ALAN (Reason: </span><span class="si">{</span><span class="n">validity_issues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">validity_issues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✓ Represents a valid TM&quot;</span><span class="p">)</span>
        
        <span class="c1"># Step 4: Simulate the TM on its own encoding</span>
        <span class="n">accepts_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_tm_on_self</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">cwl_string</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">accepts_self</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✗ TM accepts its own encoding - NOT in ALAN&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;accepts_self&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✓ TM does not accept its own encoding - IS in ALAN&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;rejects_self&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">check_tm_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transitions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if transitions form a valid TM&quot;&quot;&quot;</span>
        <span class="n">issues</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Extract states</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">])</span>
            <span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">])</span>
        
        <span class="c1"># Check for start state</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;missing_start_state&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check for halt state</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;missing_halt_state&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check for unreachable halt state</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">states</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">):</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;unreachable_halt_state&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check for duplicate transitions</span>
        <span class="n">transition_keys</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transition_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">transition_keys</span><span class="p">)):</span>
            <span class="n">issues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;duplicate_transitions&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">issues</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_tm_on_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">input_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate the TM on its own encoding&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Simulating TM on its own encoding...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Build transition table</span>
        <span class="n">trans_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
            <span class="n">trans_dict</span><span class="p">[(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">])]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s1">&#39;move&#39;</span><span class="p">])</span>
        
        <span class="c1"># Initialize simulation</span>
        <span class="n">tape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Δ&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Start state</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_steps</span> <span class="o">=</span> <span class="mi">10000</span>
        
        <span class="k">while</span> <span class="n">steps</span> <span class="o">&lt;</span> <span class="n">max_steps</span><span class="p">:</span>
            <span class="c1"># Check if we&#39;ve reached halt state</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Reached halt state after </span><span class="si">{</span><span class="n">steps</span><span class="si">}</span><span class="s2"> steps&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            
            <span class="c1"># Read current symbol</span>
            <span class="n">current_symbol</span> <span class="o">=</span> <span class="n">tape</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="k">if</span> <span class="n">head</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tape</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;Δ&#39;</span>
            
            <span class="c1"># Find transition</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current_symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trans_dict</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  No transition for (</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">, &#39;</span><span class="si">{</span><span class="n">current_symbol</span><span class="si">}</span><span class="s2">&#39;) - rejecting&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="n">next_state</span><span class="p">,</span> <span class="n">write_symbol</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">trans_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            
            <span class="c1"># Execute transition</span>
            <span class="n">tape</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_symbol</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">next_state</span>
            
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span> <span class="ow">and</span> <span class="n">head</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Exceeded max steps (</span><span class="si">{</span><span class="n">max_steps</span><span class="si">}</span><span class="s2">) - rejecting&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="n">alan_analyzer</span> <span class="o">=</span> <span class="n">ALANAnalyzer</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">line</span> <span class="mi">121</span>
<span class="g g-Whitespace">    </span><span class="mi">118</span>         <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Exceeded max steps (</span><span class="si">{</span><span class="n">max_steps</span><span class="si">}</span><span class="s2">) - rejecting&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">119</span>         <span class="k">return</span> <span class="kc">False</span>
<span class="ne">--&gt; </span><span class="mi">121</span> <span class="n">alan_analyzer</span> <span class="o">=</span> <span class="n">ALANAnalyzer</span><span class="p">()</span>

<span class="nn">Cell In[4], line 4,</span> in <span class="ni">ALANAnalyzer.__init__</span><span class="nt">(self)</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span>     <span class="bp">self</span><span class="o">.</span><span class="n">cwl_validator</span> <span class="o">=</span> <span class="n">CWLValidator</span><span class="p">()</span>
<span class="ne">----&gt; </span><span class="mi">4</span>     <span class="bp">self</span><span class="o">.</span><span class="n">tm_decoder</span> <span class="o">=</span> <span class="n">TuringMachineDecoder</span><span class="p">()</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span>     <span class="bp">self</span><span class="o">.</span><span class="n">tm_decoder</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>

<span class="ne">NameError</span>: name &#39;TuringMachineDecoder&#39; is not defined
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_alan_examples</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show various examples of strings in and not in ALAN&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">EXAMPLES OF ALAN MEMBERSHIP&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s1">&#39;string&#39;</span><span class="p">:</span> <span class="s1">&#39;ababbabbb&#39;</span><span class="p">,</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;Simple TM with one transition: (1,b)→(1,b,R)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="s1">&#39;Likely in ALAN (no halt state reachable)&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;string&#39;</span><span class="p">:</span> <span class="s1">&#39;abaabbaba&#39;</span><span class="p">,</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;TM that immediately halts: (1,a)→(2,a,L)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="s1">&#39;Check if it accepts strings starting with &quot;a&quot;&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;string&#39;</span><span class="p">:</span> <span class="s1">&#39;aaababbabbb&#39;</span><span class="p">,</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;TM with start state 3 (invalid)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="s1">&#39;In ALAN (no state 1)&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;string&#39;</span><span class="p">:</span> <span class="s1">&#39;abaaabaaabb&#39;</span> <span class="o">+</span> <span class="s1">&#39;aaaabaabbabba&#39;</span><span class="p">,</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;Two transitions: (1,a)→(3,a,R), (4,a)→(2,b,R)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="s1">&#39;In ALAN (disconnected states)&#39;</span>
        <span class="p">}</span>
    <span class="p">]</span>
    
    <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Example: </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;String: </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected: </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;expected&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">in_alan</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">alan_analyzer</span><span class="o">.</span><span class="n">analyze_alan_membership</span><span class="p">(</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Result: </span><span class="si">{</span><span class="s1">&#39;IN ALAN&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">in_alan</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;NOT IN ALAN&#39;</span><span class="si">}</span><span class="s2"> (reason: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="n">demonstrate_alan_examples</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>EXAMPLES OF ALAN MEMBERSHIP
============================================================

Example: Simple TM with one transition: (1,b)→(1,b,R)
String: ababbabbb
Expected: Likely in ALAN (no halt state reachable)

Analyzing ALAN membership for: ababbabbb...
============================================================
✓ String is in CWL

Decoding Turing Machine
Total encoding length: 9 characters
============================================================

Decoding transition starting at position 0
Substring: ababbabbb...
  From State: 1 (pos now 2)
  To State: 1 (pos now 4)
  Read Symbol: &#39;Δ&#39; (pos now 6)
  Write Symbol: &#39;#&#39; (pos now 8)
  Direction: R (pos now 9)

Transition 1: (1, &#39;Δ&#39;) → (1, &#39;#&#39;, R)

Successfully decoded single transition

Decoded TM contains a single transition
✓ Successfully decoded 1 transitions
✓ String is in ALAN (Reason: missing_halt_state)
Result: IN ALAN (reason: missing_halt_state)

Example: TM that immediately halts: (1,a)→(2,a,L)
String: abaabbaba
Expected: Check if it accepts strings starting with &quot;a&quot;

Analyzing ALAN membership for: abaabbaba...
============================================================
✗ Not in CWL, therefore not in ALAN
Result: NOT IN ALAN (reason: not_cwl)

Example: TM with start state 3 (invalid)
String: aaababbabbb
Expected: In ALAN (no state 1)

Analyzing ALAN membership for: aaababbabbb...
============================================================
✓ String is in CWL

Decoding Turing Machine
Total encoding length: 11 characters
============================================================

Decoding transition starting at position 0
Substring: aaababbabbb...
  From State: 3 (pos now 4)
  To State: 1 (pos now 6)
  Read Symbol: &#39;Δ&#39; (pos now 8)
  Write Symbol: &#39;#&#39; (pos now 10)
  Direction: R (pos now 11)

Transition 1: (3, &#39;Δ&#39;) → (1, &#39;#&#39;, R)

Successfully decoded single transition

Decoded TM contains a single transition
✓ Successfully decoded 1 transitions
✓ String is in ALAN (Reason: missing_halt_state)
Result: IN ALAN (reason: missing_halt_state)

Example: Two transitions: (1,a)→(3,a,R), (4,a)→(2,b,R)
String: abaaabaaabbaaaabaabbabba
Expected: In ALAN (disconnected states)

Analyzing ALAN membership for: abaaabaaabbaaaabaabbabba...
============================================================
✓ String is in CWL

Decoding Turing Machine
Total encoding length: 24 characters
============================================================

Decoding transition starting at position 0
Substring: abaaabaaabbaaaabaabb...
  From State: 1 (pos now 2)
  To State: 3 (pos now 6)
  Read Symbol: &#39;a&#39; (pos now 8)
  Write Symbol: &#39;b&#39; (pos now 10)
  Direction: R (pos now 11)

Transition 1: (1, &#39;a&#39;) → (3, &#39;b&#39;, R)

Decoding transition starting at position 11
Substring: aaaabaabbabba...
  From State: 4 (pos now 16)
  To State: 2 (pos now 19)
  Read Symbol: &#39;Δ&#39; (pos now 21)
  Write Symbol: &#39;#&#39; (pos now 23)
  Direction: L (pos now 24)

Transition 2: (4, &#39;Δ&#39;) → (2, &#39;#&#39;, L)

Successfully decoded all 2 transitions

Decoded TM contains 2 transitions
✓ Successfully decoded 2 transitions
✓ Represents a valid TM

Simulating TM on its own encoding...
  No transition for (3, &#39;b&#39;) - rejecting
✓ TM does not accept its own encoding - IS in ALAN
Result: IN ALAN (reason: rejects_self)
</pre></div>
</div>
</div>
</div>
</section>
<section id="turing-machine-subprograms-insert-and-delete">
<h2>1. Turing Machine Subprograms: insert and delete<a class="headerlink" href="#turing-machine-subprograms-insert-and-delete" title="Link to this heading">#</a></h2>
<p>In the context of Turing Machines, subprograms are reusable routines that perform well-defined operations. Turing machines often need to perform complex operations that involve shifting data on the tape. Two fundamental operations are <strong>insert</strong> and <strong>delete</strong> symbols, which require sophisticated subprograms since a TM can only modify one cell at a time.</p>
<section id="the-challenge-of-insert-and-delete">
<h3>1.1 The Challenge of Insert and Delete<a class="headerlink" href="#the-challenge-of-insert-and-delete" title="Link to this heading">#</a></h3>
<p>Unlike modern computers with random access memory, a Turing machine’s tape is sequential. To insert a symbol in the middle of a string, we must:</p>
<ol class="arabic simple">
<li><p>Shift all symbols to the right of the insertion point</p></li>
<li><p>Write the new symbol in the created space</p></li>
</ol>
<p>Similarly, deletion requires shifting symbols to the left to close the gap.</p>
</section>
<section id="insert">
<h3>1.2 Insert<a class="headerlink" href="#insert" title="Link to this heading">#</a></h3>
<p>Purpose: Insert a new symbol at the current position by shifting all symbols to the right one cell to make space. After the insert operation, the tape head points to the cell immediately to the right of the inserted symbol.</p>
<p>How it works:</p>
<ul class="simple">
<li><p>Store the symbol at the current position.</p></li>
<li><p>Move right and recursively shift each symbol one cell to the right.</p></li>
<li><p>After shifting, write the new symbol at the original position.</p></li>
</ul>
<p>Example Use Case:
Inserting a marker (like #) between two segments of input.</p>
</section>
<section id="delete">
<h3>1.3 Delete<a class="headerlink" href="#delete" title="Link to this heading">#</a></h3>
<p>Purpose: Deletes the symbol under the tape head, shifts all the non-blank symbols to the right of it one cell to the left to fill the gap, and ends with the tape head one cell to the right of its original position.</p>
<p>How it works:</p>
<ul class="simple">
<li><p>Find the exact position of the symbol to delete</p></li>
<li><p>Mark the position with <span class="math notranslate nohighlight">\(\#\)</span> so we can return here; creates a “hole” in the string</p></li>
<li><p>Shifting symbols leftward:</p>
<ul>
<li><p>Read next symbol to identify what needs to be shifted left</p></li>
<li><p>Write that symbol at marker position, mark next position</p></li>
<li><p>Repeat shifting until the first blank symbol</p></li>
</ul>
</li>
<li><p>Remove the last marker, completing the deletion</p></li>
</ul>
</section>
<section id="example-python-implementation">
<h3>1.4 Example Python Implementation<a class="headerlink" href="#example-python-implementation" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">visualize_insert_delete</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize insert and delete operations on a TM tape&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INSERT AND DELETE OPERATIONS&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">INSERT Operation Example:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial tape:  ...ΔabcdΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Goal: Insert &#39;X&#39; after &#39;b&#39;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Steps:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. Mark position:  ...ΔabcdΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                        ^&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. Shift right:    ...Δa.bcdΔΔ..&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4. Write X:        ...ΔaXbcdΔΔ..&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final tape:    ...ΔaXbcdΔΔ..&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                     ^&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">DELETE Operation Example:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial tape:  ...ΔabcdΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Goal: Delete &#39;c&#39;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Steps:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. Mark position:  ...ΔabcdΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                         ^&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. Rewrite:        ...Δab#dΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3. Shift left:     ...Δabd#Δ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final tape:    ...ΔabdΔΔ...&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                      ^&quot;</span><span class="p">)</span>

<span class="n">visualize_insert_delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>INSERT AND DELETE OPERATIONS
============================================================

INSERT Operation Example:
Initial tape:  ...ΔabcdΔΔ...
Goal: Insert &#39;X&#39; after &#39;b&#39;

Steps:
1. Mark position:  ...ΔabcdΔΔ...
                        ^
2. Shift right:    ...Δa.bcdΔΔ..
4. Write X:        ...ΔaXbcdΔΔ..

Final tape:    ...ΔaXbcdΔΔ..
                     ^

----------------------------------------

DELETE Operation Example:
Initial tape:  ...ΔabcdΔΔ...
Goal: Delete &#39;c&#39;

Steps:
1. Mark position:  ...ΔabcdΔΔ...
                         ^
2. Rewrite:        ...Δab#dΔΔ...
3. Shift left:     ...Δabd#Δ...

Final tape:    ...ΔabdΔΔ...
                      ^
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TuringMachineSubprogram</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape_content</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">blank_symbol</span><span class="o">=</span><span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Turing Machine Subprogram with tape content&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blank</span> <span class="o">=</span> <span class="n">blank_symbol</span>
        <span class="c1"># Convert string to list, pad with blanks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tape_content</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">blank</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;q0&#39;</span>  <span class="c1"># Start state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">display_tape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display the tape with head position&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tape content:&quot;</span><span class="p">)</span>
        <span class="c1"># Show relevant portion of tape</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">),</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span>
        
        <span class="c1"># Top row: tape content</span>
        <span class="n">tape_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">):</span>
                <span class="n">tape_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tape_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">blank</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">tape_str</span><span class="p">)</span>
        
        <span class="c1"># Bottom row: head position</span>
        <span class="n">head_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
                <span class="n">head_str</span> <span class="o">+=</span> <span class="s2">&quot; ^ &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_str</span> <span class="o">+=</span> <span class="s2">&quot;   &quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">head_str</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Head at position: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="si">}</span><span class="s2">, State: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">InsertTM</span><span class="p">(</span><span class="n">TuringMachineSubprogram</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Turing Machine that inserts a symbol at current position&quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape_content</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">symbol_to_insert</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tape_content</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_symbol</span> <span class="o">=</span> <span class="n">symbol_to_insert</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_insert_transitions</span><span class="p">()</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_build_insert_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build transition table for INSERT operation&quot;&quot;&quot;</span>
        <span class="c1"># States:</span>
        <span class="c1"># q0: Start state - mark current position</span>
        <span class="c1"># q1: Move right to find end of data</span>
        <span class="c1"># q2: Found end, start shifting right</span>
        <span class="c1"># q3: Continue shifting</span>
        <span class="c1"># q4: Return to marked position</span>
        <span class="c1"># q5: Insert new symbol</span>
        <span class="c1"># qf: Final state</span>
        
        <span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># Start: Mark current position with special marker</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;*a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;*b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;*Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            
            <span class="c1"># Move right to find end of non-blank data</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            
            <span class="c1"># Start shifting process from right to left</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;*a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;*b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;*Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            
            <span class="c1"># Shift symbols right</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;*a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;*a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;*b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;*b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;*Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;*Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            
            <span class="c1"># Write shifted symbol</span>
            <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q4&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>  <span class="c1"># Write what was saved</span>
            
            <span class="c1"># Insert new symbol and clean up</span>
            <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q5&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_symbol</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">transitions</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute INSERT operation&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">INSERT Operation: Inserting &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">insert_symbol</span><span class="si">}</span><span class="s2">&#39; at position </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_tape</span><span class="p">()</span>
        
        <span class="c1"># Simplified implementation for demonstration</span>
        <span class="c1"># Save current symbol</span>
        <span class="n">current_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">]</span>
        
        <span class="c1"># Shift everything from current position to the right</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Shift symbols right</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Insert new symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_symbol</span>
        
        <span class="c1"># Move head to right of inserted symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After INSERT:&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_tape</span><span class="p">()</span>
        
<span class="k">class</span><span class="w"> </span><span class="nc">DeleteTM</span><span class="p">(</span><span class="n">TuringMachineSubprogram</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Turing Machine Subprogram that deletes symbol at current position&quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tape_content</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tape_content</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_delete_transitions</span><span class="p">()</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_build_delete_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build transition table for DELETE operation&quot;&quot;&quot;</span>
        <span class="c1"># States:</span>
        <span class="c1"># q0: Start state - delete current symbol</span>
        <span class="c1"># q1: Move right to find next symbol</span>
        <span class="c1"># q2: Found symbol, bring it back</span>
        <span class="c1"># q3: Write symbol and continue</span>
        <span class="c1"># qf: Final state</span>
        
        <span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># Start: Delete current symbol</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>  <span class="c1"># Nothing to delete</span>
            
            <span class="c1"># Find next non-blank symbol</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>  <span class="c1"># End of data</span>
            
            <span class="c1"># Move back to write position</span>
            <span class="p">(</span><span class="s1">&#39;q2&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
            
            <span class="c1"># Write the symbol we found</span>
            <span class="p">(</span><span class="s1">&#39;q3&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>  <span class="c1"># Write saved symbol</span>
            
            <span class="c1"># Continue shifting</span>
            <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s1">&#39;qf&#39;</span><span class="p">,</span> <span class="s1">&#39;Δ&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">transitions</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute DELETE operation&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">DELETE Operation: Deleting symbol at position </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_tape</span><span class="p">()</span>
        
        <span class="c1"># Save original head position</span>
        <span class="n">original_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        
        <span class="c1"># Delete current symbol</span>
        <span class="n">deleted_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">]</span>
        
        <span class="c1"># Shift all non-blank symbols to the left</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank</span>
                <span class="k">break</span>
        
        <span class="c1"># Move head one cell to the right of original position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">original_position</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After DELETE (deleted &#39;</span><span class="si">{</span><span class="n">deleted_symbol</span><span class="si">}</span><span class="s2">&#39;):&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_tape</span><span class="p">()</span>

<span class="c1"># Demonstration functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_insert</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate INSERT operation&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INSERT OPERATION DEMONSTRATION&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="c1"># Test 1: Insert in middle</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test 1: Insert &#39;X&#39; in middle of &#39;abba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">InsertTM</span><span class="p">(</span><span class="s2">&quot;abba&quot;</span><span class="p">,</span> <span class="n">symbol_to_insert</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
    
    <span class="c1"># Test 2: Insert at beginning</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Test 2: Insert &#39;Y&#39; at beginning of &#39;abba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">InsertTM</span><span class="p">(</span><span class="s2">&quot;abba&quot;</span><span class="p">,</span> <span class="n">symbol_to_insert</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
    
    <span class="c1"># Test 3: Insert at end</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Test 3: Insert &#39;Z&#39; at end of &#39;abba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">InsertTM</span><span class="p">(</span><span class="s2">&quot;abba&quot;</span><span class="p">,</span> <span class="n">symbol_to_insert</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_delete</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate DELETE operation&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DELETE OPERATION DEMONSTRATION&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="c1"># Test 1: Delete from middle</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test 1: Delete from middle of &#39;abcba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">DeleteTM</span><span class="p">(</span><span class="s2">&quot;abcba&quot;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    
    <span class="c1"># Test 2: Delete from beginning</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Test 2: Delete from beginning of &#39;abba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">DeleteTM</span><span class="p">(</span><span class="s2">&quot;abba&quot;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    
    <span class="c1"># Test 3: Delete from end</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Test 3: Delete last symbol of &#39;abba&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">DeleteTM</span><span class="p">(</span><span class="s2">&quot;abba&quot;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    
    <span class="c1"># Test 4: Delete from single symbol</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Test 4: Delete from single symbol &#39;a&#39;&quot;</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">DeleteTM</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">head_position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

<span class="c1"># Run demonstrations</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demonstrate_insert</span><span class="p">()</span>
    <span class="n">demonstrate_delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>============================================================
INSERT OPERATION DEMONSTRATION
============================================================

Test 1: Insert &#39;X&#39; in middle of &#39;abba&#39;

INSERT Operation: Inserting &#39;X&#39; at position 2

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
       ^                                                                                  
Head at position: 2, State: q0

After INSERT:

Tape content:
[a][b][X][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
          ^                                                                               
Head at position: 3, State: q0


Test 2: Insert &#39;Y&#39; at beginning of &#39;abba&#39;

INSERT Operation: Inserting &#39;Y&#39; at position 0

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
 ^                                                                                        
Head at position: 0, State: q0

After INSERT:

Tape content:
[Y][a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
    ^                                                                                     
Head at position: 1, State: q0


Test 3: Insert &#39;Z&#39; at end of &#39;abba&#39;

INSERT Operation: Inserting &#39;Z&#39; at position 4

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
             ^                                                                            
Head at position: 4, State: q0

After INSERT:

Tape content:
[a][b][b][a][Z][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
                ^                                                                         
Head at position: 5, State: q0

============================================================
DELETE OPERATION DEMONSTRATION
============================================================

Test 1: Delete from middle of &#39;abcba&#39;

DELETE Operation: Deleting symbol at position 2

Tape content:
[a][b][c][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
       ^                                                                                  
Head at position: 2, State: q0

After DELETE (deleted &#39;c&#39;):

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
          ^                                                                               
Head at position: 3, State: q0


Test 2: Delete from beginning of &#39;abba&#39;

DELETE Operation: Deleting symbol at position 0

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
 ^                                                                                        
Head at position: 0, State: q0

After DELETE (deleted &#39;a&#39;):

Tape content:
[b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
    ^                                                                                     
Head at position: 1, State: q0


Test 3: Delete last symbol of &#39;abba&#39;

DELETE Operation: Deleting symbol at position 3

Tape content:
[a][b][b][a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
          ^                                                                               
Head at position: 3, State: q0

After DELETE (deleted &#39;a&#39;):

Tape content:
[a][b][b][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
             ^                                                                            
Head at position: 4, State: q0


Test 4: Delete from single symbol &#39;a&#39;

DELETE Operation: Deleting symbol at position 0

Tape content:
[a][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
 ^                                                                                        
Head at position: 0, State: q0

After DELETE (deleted &#39;a&#39;):

Tape content:
[Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ][Δ]
    ^                                                                                     
Head at position: 1, State: q0
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id1">
<h2>2. The Universal Turing Machine<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>The Universal Turing Machine (UTM) is one of the most influential concepts in computer science. Its impact goes far beyond its original purpose, shaping how we understand computation, logic, and the limits of what can be computed.</p>
<section id="definition-of-the-universal-turing-machine">
<h3>2.1 Definition of The Universal Turing Machine<a class="headerlink" href="#definition-of-the-universal-turing-machine" title="Link to this heading">#</a></h3>
<p>The Universal Turing Machine (UTM) is a Turing machine that can simulate the behavior of any other Turing machine. It is a general-purpose Turing machine that takes as input:</p>
<ul class="simple">
<li><p>The encoding of a Turing machine <span class="math notranslate nohighlight">\(T\)</span>, and</p></li>
<li><p>An input string <span class="math notranslate nohighlight">\(w\)</span> to be processed by <span class="math notranslate nohighlight">\(T\)</span></p></li>
</ul>
<p>It then simulates the steps <span class="math notranslate nohighlight">\(T\)</span> would take if it were running on <span class="math notranslate nohighlight">\(w\)</span>.</p>
</section>
<section id="why-study-the-universal-turing-machine">
<h3>2.2 Why Study The Universal Turing Machine<a class="headerlink" href="#why-study-the-universal-turing-machine" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>A Blueprint for All Computers: The UTM introduced the idea that a single machine could simulate any other Turing machine if given a suitable encoded description. This principle of universality overturned the idea that each problem required a custom-built machine. Instead, one machine could perform any computation, an idea that directly inspired the stored-program architecture developed by von Neumann. Every smartphone, laptop, and supercomputer today is essentially a practical realization of Turing’s universal machine, capable of running any computable algorithm when given the right software.</p></li>
<li><p>Foundation of Church’s Thesis: The UTM provides strong support for Church’s thesis, which proposes that anything computable by an algorithm can be computed by a Turing machine. While the thesis isn’t formally provable, the existence of the UTM offers compelling evidence: it shows that Turing machines can simulate any algorithmic process, defining the very nature of computation itself.</p></li>
<li><p>Tool for Proving Undecidability: The UTM makes it possible to encode machines as data, enabling groundbreaking results like Turing’s Halting Problem proof. Feeding a machine its own description introduces self-reference, unlocking diagonalization techniques that show some problems are fundamentally unsolvable. This approach has been crucial in proving the undecidability of many other problems, such as the Post Correspondence Problem and questions about program behavior.</p></li>
<li><p>Enabling Self-Referential Languages: The ability to encode machines gives rise to self-referential programming languages, like ALAN and MATHISON. These languages describe machines that act on their own encodings—for example, rejecting or accepting their own descriptions. This self-reference deepens our understanding of logic and paradox, and it all stems from the UTM’s encoding capability.</p></li>
<li><p>Separating Software from Hardware: The UTM shows that computation is an abstract process, independent of the physical device performing it. This insight underlies the distinction between software and hardware: the same program can run on many devices, and a single machine can run many programs. This flexibility defines modern computing and is a direct consequence of the UTM’s universality.</p></li>
<li><p>Philosophical and Cognitive Implications: The UTM raises deep philosophical questions about the nature of mind and intelligence. If the human brain operates algorithmically, then it could, in theory, be simulated by a UTM. This supports computational theories of mind but also introduces limits—if the UTM has boundaries, so might any computational model of intelligence.</p></li>
<li><p>Lasting Historical Significance: When Alan Turing introduced the UTM in 1936, no physical computers existed. Yet his work laid the intellectual foundation for their eventual development. The UTM not only influenced von Neumann’s architecture but also helped define computer science as a discipline, impacting future work in areas like quantum computing and DNA computing.</p></li>
</ul>
<p>The reasons outlined here highlight some of the most significant impacts of the Universal Turing Machine, but this is by no means an exhaustive list. There are additional theoretical, practical, and philosophical implications that continue to emerge. For a deeper exploration, consider consulting further readings in computability theory, computational complexity, recursion theory, and the philosophy of computation.</p>
</section>
<section id="real-world-applications-of-the-universal-turing-machine">
<h3>2.3 Real-World Applications of The Universal Turing Machine<a class="headerlink" href="#real-world-applications-of-the-universal-turing-machine" title="Link to this heading">#</a></h3>
<p>The UTM’s legacy lives on in many areas of modern computing:</p>
<ul class="simple">
<li><p>Virtual Machines &amp; Emulators: Systems that simulate other machines are direct applications of the UTM concept.</p></li>
<li><p>Interpreters &amp; Compilers: These tools are essentially specialized UTMs, converting and executing code written in various languages.</p></li>
<li><p>Proof Assistants &amp; Verification Tools: These rely on the UTM’s encoding methods to reason formally about programs.</p></li>
</ul>
</section>
<section id="why-the-utm-exists">
<h3>2.4 Why the UTM Exists<a class="headerlink" href="#why-the-utm-exists" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Finite Descriptions of Infinite Processes: The UTM exists because every Turing machine can be described using a finite set of rules, even if its computation might run forever. These states, symbols, and transitions can be written down as a finite string. Since Turing machines can read and process strings, one machine can be built to read and simulate the behavior of any other machine based on its description. The process may be endless, but the instructions are always limited and manageable.</p></li>
<li><p>Computation Can Simulate Computation: Computation is powerful enough to describe itself. Just like how mathematics can describe math, a Turing machine can simulate another Turing machine. If we can compute functions and represent machines as strings, then we can also compute a function that simulates any machine given its description. That’s exactly what the UTM does.</p></li>
<li><p>Computation Is Just Symbol Manipulation: Turing realized that all computation is really just following rules to move and change symbols. Since machine descriptions are also made of symbols, a machine can read and process these to simulate other machines. In other words, symbols can describe how to manipulate symbols, including descriptions of machines that do this themselves.</p></li>
</ul>
<p>This ability for machines to work with their own descriptions isn’t a paradox, it’s the very reason why general-purpose computers are possible.</p>
</section>
<section id="how-to-construct-the-utm">
<h3>2.5 How to Construct the UTM<a class="headerlink" href="#how-to-construct-the-utm" title="Link to this heading">#</a></h3>
<p>Constructing the UTM requires careful design to handle the simulation of arbitrary Turing machines. In the following description, we use <span class="math notranslate nohighlight">\(U\)</span> to refer to the Universal Turing Machine and <span class="math notranslate nohighlight">\(T\)</span> to represent the Turing machine that <span class="math notranslate nohighlight">\(U\)</span> is simulating. For simplicity, we refer to the tape head as the head. Here’s a detailed approach to building one:</p>
<section id="step-1-design-the-encoding-scheme">
<h4>2.5.1 Step 1: Design the Encoding Scheme<a class="headerlink" href="#step-1-design-the-encoding-scheme" title="Link to this heading">#</a></h4>
<p>First, we must establish how to encode any Turing machine as a string. A commonly used method for systematically encoding Turing machines was introduced in a previous chapter.</p>
</section>
<section id="step-2-design-the-utm-s-tape-layout">
<h4>2.5.2 Step 2: Design the UTM’s Tape Layout<a class="headerlink" href="#step-2-design-the-utm-s-tape-layout" title="Link to this heading">#</a></h4>
<p>The UTM’s tape must store both the encoded machine and the simulated machine’s tape. A three-track setup is effective: Track 1 holds the fixed machine description; Track 2 stores the simulated tape, and Track 3 tracks the current state. Another common approach is to use a single tape with delimiters. The tape of <span class="math notranslate nohighlight">\(U\)</span> is divided into two main sections, separated by special delimiters <span class="math notranslate nohighlight">\(\#\)</span> and <span class="math notranslate nohighlight">\(\$\)</span>: as illustrated in the UTM Tape Organization figure below. This single tape contains everything needed for <span class="math notranslate nohighlight">\(U\)</span> to simulate any other Turing machine.</p>
<ul class="simple">
<li><p>The Encoded Turing Machine Section (between <span class="math notranslate nohighlight">\(\#\)</span> and <span class="math notranslate nohighlight">\(\$\)</span>): This section contains the complete description of <span class="math notranslate nohighlight">\(T\)</span>, encoded in CWL format using only <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> symbols. It acts like a program written directly on the tape. This encoding allows <span class="math notranslate nohighlight">\(U\)</span> to mechanically simulate the behavior of <span class="math notranslate nohighlight">\(T\)</span>, regardless of what <span class="math notranslate nohighlight">\(T\)</span> actually does.</p>
<ul>
<li><p>The encoding is finite and static throughout the simulation.</p></li>
<li><p>It contains all the transition rules of <span class="math notranslate nohighlight">\(T\)</span> and uses a consistent format.</p></li>
</ul>
</li>
<li><p>The Data Section (after the <span class="math notranslate nohighlight">\(\$\)</span> delimiter): This section contains the input and workspace for the simulation:</p>
<ul>
<li><p>Input string (shown as <span class="math notranslate nohighlight">\(babba\)</span>): The actual input data that <span class="math notranslate nohighlight">\(T\)</span> will process</p></li>
<li><p>Blank symbols (Δ): Representing infinite blank cells to the right, simulating an unbounded tape</p></li>
</ul>
</li>
<li><p>The Read Head:</p>
<ul>
<li><p>The red arrow pointing to cell <span class="math notranslate nohighlight">\(b\)</span> shows the current position of <span class="math notranslate nohighlight">\(T\)</span>’s head.</p></li>
<li><p>This is different from <span class="math notranslate nohighlight">\(U\)</span>’s own head, which moves back and forth across the entire tape during simulation.</p></li>
</ul>
</li>
</ul>
<p>The beauty of this design is that <span class="math notranslate nohighlight">\(U\)</span> doesn’t need to “understand” what the encoded machine does, it just mechanically follows the rules encoded in the first section to manipulate the data in the second section, achieving true universal computation:</p>
<ul class="simple">
<li><p>Self-containment: Everything needed for computation is on one tape - both the “program” (encoded TM) and the “data”</p></li>
<li><p>Universality: By changing what’s between <span class="math notranslate nohighlight">\(\#\)</span> and <span class="math notranslate nohighlight">\(\$\)</span>, the same UTM can simulate any Turing machine</p></li>
<li><p>Stored-program concept: This is the theoretical foundation for modern computers where programs and data share the same memory</p></li>
<li><p>Finite description, infinite tape: Although the TM description is finite, the data section can extend infinitely to the right</p></li>
</ul>
<p>The single tape organization with delimiters is shown below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Load and display an SVG file in Jupyter notebook&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVG</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">HTML</span><span class="p">,</span> <span class="n">Markdown</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rectangle</span>

<span class="c1"># Load SVG from file</span>
<span class="k">def</span><span class="w"> </span><span class="nf">load_svg_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load SVG content from a file&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">svg_content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SVG loaded from </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">svg_content</span>

<span class="n">svg_content</span> <span class="o">=</span> <span class="n">load_svg_from_file</span><span class="p">(</span><span class="s1">&#39;utm_tape.svg&#39;</span><span class="p">)</span>

<span class="n">html_with_caption</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;figure style=&quot;text-align: center; margin: 20px 0;&quot;&gt;</span>
<span class="s2">    </span><span class="si">{</span><span class="n">svg_content</span><span class="si">}</span>
<span class="s2">    &lt;figcaption style=&quot;margin-top: 10px; font-style: italic; color: #666;&quot;&gt;</span>
<span class="s2">        Figure 1: A UTM Tape</span>
<span class="s2">    &lt;/figcaption&gt;</span>
<span class="s2">&lt;/figure&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">display</span><span class="p">(</span><span class="n">HTML</span><span class="p">(</span><span class="n">html_with_caption</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SVG loaded from utm_tape.svg
</pre></div>
</div>
<div class="output text_html">
<figure style="text-align: center; margin: 20px 0;">
    
    <svg width="900" height="250" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <style>
                .section { fill: none; stroke: #666; stroke-width: 1; stroke-dasharray: 5,5; }
                .tape-bg { fill: #f9f9f9; stroke: none; }
                .cell { fill: white; stroke: black; stroke-width: 1.5; }
                .delimiter { fill: #ddd; stroke: black; stroke-width: 2; }
                .highlight { fill: #ffd700; fill-opacity: 0.3; }
                .text { font-family: 'Consolas', 'Monaco', monospace; font-size: 14px; }
                .label { font-family: Arial, sans-serif; font-size: 13px; fill: #444; }
                .title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; }
            </style>
        </defs>
        
        <text x="450" y="25" class="title" text-anchor="middle">UTM Tape Organization</text>
        
        <!-- Background sections -->
        <rect x="30" y="60" width="840" height="80" class="tape-bg"/>
        
        <!-- Section 1: Machine Description -->
        <g id="machine-section">
            <rect x="50" y="70" width="320" height="60" class="section highlight"/>
            <text x="210" y="55" class="label" text-anchor="middle">Encoded Turing Machine</text>
            
            <rect x="60" y="80" width="30" height="40" class="delimiter"/>
            <text x="75" y="105" class="text" text-anchor="middle">#</text>
            
            <!-- Encoded TM cells showing a's and b's -->
            <rect x="90" y="80" width="25" height="40" class="cell"/>
            <text x="102.5" y="105" class="text" text-anchor="middle">a</text>
            
            <rect x="115" y="80" width="25" height="40" class="cell"/>
            <text x="127.5" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="140" y="80" width="25" height="40" class="cell"/>
            <text x="152.5" y="105" class="text" text-anchor="middle">a</text>
            
            <rect x="165" y="80" width="25" height="40" class="cell"/>
            <text x="177.5" y="105" class="text" text-anchor="middle">a</text>
            
            <rect x="190" y="80" width="25" height="40" class="cell"/>
            <text x="202.5" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="215" y="80" width="25" height="40" class="cell"/>
            <text x="227.5" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="240" y="80" width="25" height="40" class="cell"/>
            <text x="252.5" y="105" class="text" text-anchor="middle">a</text>
            
            <rect x="265" y="80" width="25" height="40" class="cell"/>
            <text x="277.5" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="290" y="80" width="40" height="40" class="cell"/>
            <text x="310" y="105" class="text" text-anchor="middle">...</text>
            
            <text x="195" y="145" class="label" text-anchor="middle" font-size="11">(CWL encoding)</text>
            
            <rect x="330" y="80" width="30" height="40" class="delimiter"/>
            <text x="345" y="105" class="text" text-anchor="middle">$</text>
        </g>
        
        <!-- Section 2: Data (Input to simulated TM) -->
        <g id="data-section">
            <rect x="370" y="70" width="390" height="60" class="section highlight"/>
            <text x="565" y="55" class="label" text-anchor="middle">Data (Input String + Blanks)</text>
            
            <!-- Data cells - string of a's and b's -->
            <rect x="380" y="80" width="30" height="40" class="cell"/>
            <text x="395" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="410" y="80" width="30" height="40" class="cell"/>
            <text x="425" y="105" class="text" text-anchor="middle">a</text>
            
            <rect x="440" y="80" width="30" height="40" class="cell" style="fill: #ffcccc;"/>
            <text x="455" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="470" y="80" width="30" height="40" class="cell"/>
            <text x="485" y="105" class="text" text-anchor="middle">b</text>
            
            <rect x="500" y="80" width="30" height="40" class="cell"/>
            <text x="515" y="105" class="text" text-anchor="middle">a</text>
            
            <!-- Blank symbols -->
            <rect x="530" y="80" width="30" height="40" class="cell"/>
            <text x="545" y="105" class="text" text-anchor="middle">Δ</text>
            
            <rect x="560" y="80" width="30" height="40" class="cell"/>
            <text x="575" y="105" class="text" text-anchor="middle">Δ</text>
            
            <rect x="590" y="80" width="30" height="40" class="cell"/>
            <text x="605" y="105" class="text" text-anchor="middle">Δ</text>
            
            <rect x="620" y="80" width="30" height="40" class="cell"/>
            <text x="635" y="105" class="text" text-anchor="middle">...</text>
            
            <text x="515" y="145" class="label" text-anchor="middle" font-size="11">(input string)</text>
            <text x="590" y="145" class="label" text-anchor="middle" font-size="11">(blanks)</text>
            
            <rect x="650" y="80" width="30" height="40" class="delimiter"/>
            <text x="665" y="105" class="text" text-anchor="middle">#</text>
        </g>
        
        <!-- Head pointer at bottom pointing up -->
        <path d="M 450 130 L 460 130 L 455 120 Z" fill="red"/>
        <text x="445" y="145" class="label" text-anchor="middle" fill="red" font-size="11">read head</text>
        
        <!-- Explanatory notes -->
        <g id="notes" transform="translate(0, 170)">
            <text x="50" y="0" class="label" font-size="12">Components:</text>
            <text x="70" y="20" class="label" font-size="11">• # = Start/End delimiter</text>
            <text x="70" y="35" class="label" font-size="11">• abaabbab... = Encoded TM in CWL format</text>
            <text x="70" y="50" class="label" font-size="11">• $ = Separator between TM encoding and data</text>
            <text x="70" y="65" class="label" font-size="11">• babba = Input data string (a's and b's)</text>
            <text x="400" y="20" class="label" font-size="11">• Δ = Blank symbols (infinite tape)</text>
            <text x="400" y="35" class="label" font-size="11">• Red cell = Current position of simulated TM's head</text>
            <text x="400" y="50" class="label" font-size="11">• ... = Tape continues infinitely</text>
        </g>
    </svg>
    
    <figcaption style="margin-top: 10px; font-style: italic; color: #666;">
        Figure 1: A UTM Tape
    </figcaption>
</figure>
</div></div>
</div>
</section>
<section id="step-3-design-the-utm-s-state-structure">
<h4>2.5.3 Step 3: Design the UTM’s State Structure<a class="headerlink" href="#step-3-design-the-utm-s-state-structure" title="Link to this heading">#</a></h4>
<p>The UTM needs states for different phases of simulation:</p>
<ul class="simple">
<li><p>Initialization States:</p>
<ul>
<li><p>Start in the START state (<span class="math notranslate nohighlight">\(U\)</span>’s state 1).</p></li>
<li><p>Search for the beginning of the input string <span class="math notranslate nohighlight">\(w\)</span> on the UTM’s tape, which is located after the encoded Turing Machine description.</p></li>
<li><p>Once the first symbol of <span class="math notranslate nohighlight">\(w\)</span> is found, insert <span class="math notranslate nohighlight">\(T\)</span>’s start state (<span class="math notranslate nohighlight">\(q_1\)</span>) on the tape, shifting <span class="math notranslate nohighlight">\(w\)</span> one cell to the right. This <span class="math notranslate nohighlight">\(q_1\)</span> marks where <span class="math notranslate nohighlight">\(T\)</span>’s head is currently located.</p></li>
<li><p>From now on:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(U\)</span>’s head is used to simulate <span class="math notranslate nohighlight">\(T\)</span>’s head. The special <span class="math notranslate nohighlight">\(q\)</span> symbol shows the position of <span class="math notranslate nohighlight">\(T\)</span>’s head, refer to it as q-marker.</p></li>
<li><p>The data section of <span class="math notranslate nohighlight">\(U\)</span>’s tape (after the <span class="math notranslate nohighlight">\(\$\)</span> marker) reflects <span class="math notranslate nohighlight">\(T\)</span>’s tape.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Simulation Cycle States: Repeat the following simulation loop until the simulated machine reaches its HALT state.</p>
<ul>
<li><p>Find-Transition States: When <span class="math notranslate nohighlight">\(U\)</span> reads a tape symbol <span class="math notranslate nohighlight">\(s_x\)</span> and sees that the machine is in state <span class="math notranslate nohighlight">\(q_x\)</span>, we treat the pair of (<span class="math notranslate nohighlight">\(q_x\)</span>, <span class="math notranslate nohighlight">\(s_x\)</span> ) as a state of <span class="math notranslate nohighlight">\(U\)</span>, also referred to as a meta-state, which represents or tracks information about the states and symbols of the simulated machine, rather than directly participating in the main computation. The simulation starts with <span class="math notranslate nohighlight">\(q_x\)</span> as the current state of <span class="math notranslate nohighlight">\(T\)</span> and reads the symbol <span class="math notranslate nohighlight">\(s_x\)</span>:</p>
<ul>
<li><p>Move left across the <span class="math notranslate nohighlight">\(\$\)</span> barrier into the Turing Machine code section, search for the substring representing the transition: <span class="math notranslate nohighlight">\((q_x, s_x)\)</span></p>
<ul>
<li><p>If found: proceed to simulate the transition.</p></li>
<li><p>If not found: simulate a crash (i.e., undefined transition).</p></li>
</ul>
</li>
<li><p>Mark the found transition:</p>
<ul>
<li><p>Change state to a “blue” version of <span class="math notranslate nohighlight">\(q_x\)</span> to bookmark your place</p></li>
<li><p>Extract the transition details: next state (<span class="math notranslate nohighlight">\(q_y\)</span>). write symbol (<span class="math notranslate nohighlight">\(s_w\)</span>), move direction (<span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(R\)</span>)</p></li>
</ul>
</li>
<li><p>Write New Symbol to <span class="math notranslate nohighlight">\(T\)</span>’s tape:</p>
<ul>
<li><p>Return across the <span class="math notranslate nohighlight">\(\$\)</span> to <span class="math notranslate nohighlight">\(T\)</span>’s tape.</p></li>
<li><p>Find the q-marker (which shows where <span class="math notranslate nohighlight">\(T\)</span>’s head was).</p></li>
<li><p>Replace the symbol to the right of q-marker with the new symbol (<span class="math notranslate nohighlight">\(s_w\)</span>).</p></li>
</ul>
</li>
<li><p>Move the Head: Based on the move direction <span class="math notranslate nohighlight">\(D\)</span> and the next state <span class="math notranslate nohighlight">\(q_y\)</span>, <span class="math notranslate nohighlight">\(U\)</span> transitions into its meta-state (<span class="math notranslate nohighlight">\(q_y\)</span>, <span class="math notranslate nohighlight">\(D\)</span>), and the simulation proceeds as follows:</p>
<ul>
<li><p>Move right across the <span class="math notranslate nohighlight">\(\$\)</span> barrier into <span class="math notranslate nohighlight">\(T\)</span>’s tape section, find <span class="math notranslate nohighlight">\(q_x\)</span> and delete it.</p></li>
<li><p>If L: move the head two cells left (because delete subprogram moves the head one cell to the right after deletion), insert <span class="math notranslate nohighlight">\(q_y\)</span>.</p></li>
<li><p>If R: move the head one cell right, insert <span class="math notranslate nohighlight">\(q_y\)</span>.</p></li>
</ul>
</li>
<li><p>Continue the imulation by reading the next symbol:</p>
<ul>
<li><p>Read the symbol <span class="math notranslate nohighlight">\(s_y\)</span> now under the head</p></li>
<li><p><span class="math notranslate nohighlight">\(U\)</span> transitions into the next meta-state (<span class="math notranslate nohighlight">\(q_y\)</span>, <span class="math notranslate nohighlight">\(s_y\)</span>) and repeat the whole process.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Halting States: When <span class="math notranslate nohighlight">\(T\)</span>’s next state <span class="math notranslate nohighlight">\(q_y\)</span> is <span class="math notranslate nohighlight">\(q_2\)</span> (HALT):</p>
<ul>
<li><p>Scan <span class="math notranslate nohighlight">\(T\)</span>’s tape for the remaining q-marker.</p></li>
<li><p>Remove the last q symbol.</p></li>
<li><p>Transition <span class="math notranslate nohighlight">\(U\)</span> into the HALT state.</p></li>
</ul>
</li>
</ul>
<p>This simulation proves a powerful fact: a single machine can run any program, and forms the theoretical basis for stored-program computers.</p>
</section>
<section id="id2">
<h4>2.5.4 Example Python Implementation<a class="headerlink" href="#id2" title="Link to this heading">#</a></h4>
<p>The following implementation demonstrates the UTM principles using a simplified encoding rather than the formal CWL standard that would be used in a complete theoretical implementation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Universal Turing Machine Implementation</span>
<span class="sd">Based on the detailed construction steps provided in section 3.5</span>

<span class="sd">This implementation follows the exact methodology:</span>
<span class="sd">- Single tape with # and $ delimiters</span>
<span class="sd">- Encoded TM section between # and $, Note: For simplicity, we are using a basic comma-separated format instead of the CWL code word format.</span>
<span class="sd">- Data section after $</span>
<span class="sd">- Meta-states for simulation phases</span>
<span class="sd">- q-marker system for tracking simulated machine&#39;s head</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">UniversalTuringMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Universal Turing Machine implementation following the specified construction steps.</span>
<span class="sd">    </span>
<span class="sd">    Tape Layout: [UTM_states]#[ENCODED_TM]$[q1][INPUT_DATA][blank_cells...]</span>
<span class="sd">    </span>
<span class="sd">    Key Components:</span>
<span class="sd">    - # and $ delimiters separate sections</span>
<span class="sd">    - Encoded TM section (between # and $) </span>
<span class="sd">    - Data section (after $) with q-marker tracking simulated head</span>
<span class="sd">    - Meta-states representing (qx, sx) pairs</span>
<span class="sd">    - Simulation cycle with find-transition, apply-transition phases</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;START&#39;</span>  <span class="c1"># UTM&#39;s current state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation_steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_steps</span> <span class="o">=</span> <span class="mi">1000</span>
        
        <span class="c1"># Special symbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_HASH</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_DOLLAR</span> <span class="o">=</span> <span class="s1">&#39;$&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span> <span class="o">=</span> <span class="s1">&#39;Δ&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q_MARKER_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;q&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BLUE_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;BLUE_&#39;</span>
        
        <span class="c1"># UTM state types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">INITIALIZATION_STATES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="s1">&#39;FIND_INPUT&#39;</span><span class="p">,</span> <span class="s1">&#39;INSERT_Q1&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMULATION_STATES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FIND_TRANSITION&#39;</span><span class="p">,</span> <span class="s1">&#39;MARK_TRANSITION&#39;</span><span class="p">,</span> <span class="s1">&#39;APPLY_TRANSITION&#39;</span><span class="p">,</span> 
                                <span class="s1">&#39;WRITE_SYMBOL&#39;</span><span class="p">,</span> <span class="s1">&#39;MOVE_HEAD&#39;</span><span class="p">,</span> <span class="s1">&#39;CONTINUE_SIMULATION&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HALTING_STATES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CLEANUP&#39;</span><span class="p">,</span> <span class="s1">&#39;HALT&#39;</span><span class="p">]</span>
        
        <span class="c1"># Track simulation state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Current state of simulated machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># Current symbol being read by simulated machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Found transition details</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blue_marker_pos</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Position of blue marker in encoded section</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_tape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 2: Initialize UTM tape with encoded TM and input data.</span>
<span class="sd">        </span>
<span class="sd">        Tape layout: #[ENCODED_TM]$[INPUT_STRING]</span>
<span class="sd">        Later we&#39;ll insert q1 marker at the beginning of input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initializing UTM tape...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encoded TM: </span><span class="si">{</span><span class="n">encoded_tm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input string: </span><span class="si">{</span><span class="n">input_string</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Build tape: # + encoded_tm + $ + input_string + blanks</span>
        <span class="n">tape_content</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_HASH</span> <span class="o">+</span> <span class="n">encoded_tm</span> <span class="o">+</span> 
                       <span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_DOLLAR</span> <span class="o">+</span> <span class="n">input_string</span><span class="p">)</span>
        
        <span class="c1"># Add some blank cells for workspace</span>
        <span class="n">tape_content</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span> <span class="o">*</span> <span class="mi">10</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tape_content</span><span class="p">)</span>
        
        <span class="c1"># Start UTM head at the beginning of data section (after $)</span>
        <span class="n">dollar_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_DOLLAR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">=</span> <span class="n">dollar_pos</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_tape_state</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">find_delimiter_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find positions of # and $ delimiters&quot;&quot;&quot;</span>
        <span class="n">hash_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_HASH</span><span class="p">)</span>
        <span class="n">dollar_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DELIMITER_DOLLAR</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hash_pos</span><span class="p">,</span> <span class="n">dollar_pos</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_encoded_tm_section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the encoded TM section (between # and $)&quot;&quot;&quot;</span>
        <span class="n">hash_pos</span><span class="p">,</span> <span class="n">dollar_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_delimiter_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">hash_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">dollar_pos</span><span class="p">])</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_data_section_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get starting position of data section (after $)&quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dollar_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_delimiter_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dollar_pos</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">print_tape_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Debug helper to print current tape state&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">return</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UTM State: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Print tape with head indicator</span>
        <span class="n">tape_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">))])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tape: </span><span class="si">{</span><span class="n">tape_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Print head position indicator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">:</span>
            <span class="n">head_indicator</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">head_indicator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Head position: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head_position</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulated machine state: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulated symbol: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_1_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 3: START state - begin UTM execution</span>
<span class="sd">        Search for beginning of input string (after $)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 1: Starting UTM execution&quot;</span><span class="p">)</span>
        
        <span class="c1"># Move to beginning of data section</span>
        <span class="n">data_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_section_start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">=</span> <span class="n">data_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;FIND_INPUT&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_2_find_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the beginning of input string and prepare to insert q1 marker</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 2: Finding input string start&quot;</span><span class="p">)</span>
        
        <span class="c1"># We&#39;re already at the start of input (after $)</span>
        <span class="c1"># Prepare to insert q1 marker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;INSERT_Q1&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_3_insert_q1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert T&#39;s start state (q1) at the beginning of input, shifting input right</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 3: Inserting q1 marker&quot;</span><span class="p">)</span>
        
        <span class="c1"># Insert q1 at current position</span>
        <span class="n">q1_marker</span> <span class="o">=</span> <span class="s1">&#39;q1&#39;</span>
        
        <span class="c1"># Shift everything to the right to make space</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">q1_marker</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_position</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
        
        <span class="c1"># Now q1 is inserted, move head to the symbol after q1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q1_marker</span><span class="p">)</span>
        
        <span class="c1"># Initialize simulation state tracking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span> <span class="o">=</span> <span class="s1">&#39;q1&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_position</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;FIND_TRANSITION&#39;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inserted q1 marker, now reading symbol: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">find_q_marker_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the position of the q-marker in the data section</span>
<span class="sd">        Returns (q_state, position_of_q, position_after_q, symbol_being_read)</span>
<span class="sd">        </span>
<span class="sd">        The q-marker format is: q followed by exactly ONE digit, then the symbol being read</span>
<span class="sd">        Example: q1 followed by symbol &#39;0&#39; means state q1 reading symbol 0</span>
<span class="sd">        </span>
<span class="sd">        IMPORTANT: We only read ONE digit after &#39;q&#39; to avoid consuming input digits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_section_start</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span> <span class="ow">and</span> 
                <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                
                <span class="c1"># Extract exactly q + one digit (e.g., &quot;q1&quot;, &quot;q2&quot;, &quot;q3&quot;)</span>
                <span class="n">q_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Only q + one digit</span>
                
                <span class="c1"># The symbol being read is right after the q-state</span>
                <span class="n">symbol_pos</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># Skip &#39;q&#39; and one digit</span>
                <span class="k">if</span> <span class="n">symbol_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">):</span>
                    <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">symbol_pos</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found q-marker: state=&#39;</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">&#39; at pos </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">, symbol=&#39;</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&#39; at pos </span><span class="si">{</span><span class="n">symbol_pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="k">return</span> <span class="n">q_state</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">symbol</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No q-marker found in data section&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_4_find_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 4: Find transition in encoded TM section</span>
<span class="sd">        Search for substring representing transition (qx, sx)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, locate the q-marker and current symbol</span>
        <span class="n">q_state</span><span class="p">,</span> <span class="n">q_pos</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_q_marker_position</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">q_state</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: No q-marker found in data section&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;HALT&#39;</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span> <span class="o">=</span> <span class="n">q_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span> <span class="o">=</span> <span class="n">symbol</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step 4: Looking for transition (</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check for halt condition</span>
        <span class="k">if</span> <span class="n">q_state</span> <span class="o">==</span> <span class="s1">&#39;q2&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reached halt state q2&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;CLEANUP&#39;</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="c1"># Search in encoded TM section for transition</span>
        <span class="n">encoded_section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_encoded_tm_section</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Searching for transition: </span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In encoded section: </span><span class="si">{</span><span class="n">encoded_section</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Parse transitions from encoded section</span>
        <span class="c1"># Format: q1,a,q2,b,R|q2,b,q1,a,L|...</span>
        <span class="n">transitions</span> <span class="o">=</span> <span class="n">encoded_section</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">transition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transitions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">transition</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="k">continue</span>
                
            <span class="n">parts</span> <span class="o">=</span> <span class="n">transition</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">from_state</span><span class="p">,</span> <span class="n">read_symbol</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">write_symbol</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Checking transition: </span><span class="si">{</span><span class="n">from_state</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">read_symbol</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">to_state</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">write_symbol</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">from_state</span> <span class="o">==</span> <span class="n">q_state</span> <span class="ow">and</span> <span class="n">read_symbol</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;from_state&#39;</span><span class="p">:</span> <span class="n">from_state</span><span class="p">,</span>
                        <span class="s1">&#39;read_symbol&#39;</span><span class="p">:</span> <span class="n">read_symbol</span><span class="p">,</span>
                        <span class="s1">&#39;to_state&#39;</span><span class="p">:</span> <span class="n">to_state</span><span class="p">,</span>
                        <span class="s1">&#39;write_symbol&#39;</span><span class="p">:</span> <span class="n">write_symbol</span><span class="p">,</span>
                        <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="n">direction</span><span class="p">,</span>
                        <span class="s1">&#39;transition_index&#39;</span><span class="p">:</span> <span class="n">i</span>
                    <span class="p">}</span>
                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✓ Found matching transition: </span><span class="si">{</span><span class="n">transition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;MARK_TRANSITION&#39;</span>
                    <span class="k">return</span> <span class="kc">True</span>
        
        <span class="c1"># No transition found - simulate crash</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✗ No transition found for (</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">) - simulating crash&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;HALT&#39;</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_5_mark_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 5: Mark the found transition with blue marker</span>
<span class="sd">        Extract transition details for simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 5: Marking transition (blue marker)&quot;</span><span class="p">)</span>
        
        <span class="c1"># In a full implementation, we would mark the transition blue</span>
        <span class="c1"># For simplicity, we&#39;ll just track that we found it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blue_marker_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span><span class="p">[</span><span class="s1">&#39;transition_index&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Marked transition at index </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_marker_pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transition details: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;WRITE_SYMBOL&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_6_write_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 6: Write new symbol to T&#39;s tape</span>
<span class="sd">        Return to data section and replace symbol after q-marker</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 6: Writing new symbol to simulated tape&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find q-marker position again</span>
        <span class="n">q_state</span><span class="p">,</span> <span class="n">q_pos</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">current_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_q_marker_position</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">symbol_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">symbol_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">):</span>
            <span class="n">new_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span><span class="p">[</span><span class="s1">&#39;write_symbol&#39;</span><span class="p">]</span>
            <span class="n">old_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">symbol_pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">symbol_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_symbol</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Replaced &#39;</span><span class="si">{</span><span class="n">old_symbol</span><span class="si">}</span><span class="s2">&#39; with &#39;</span><span class="si">{</span><span class="n">new_symbol</span><span class="si">}</span><span class="s2">&#39; at position </span><span class="si">{</span><span class="n">symbol_pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tape after write: </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="mi">50</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not find symbol position to write to&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;MOVE_HEAD&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_7_move_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 7: Move the head based on transition direction</span>
<span class="sd">        Delete old q-marker and insert new q-marker at appropriate position</span>
<span class="sd">        </span>
<span class="sd">        Q-markers are always exactly 2 characters: &#39;q&#39; + one digit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 7: Moving simulated machine head&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find current q-marker</span>
        <span class="n">q_state</span><span class="p">,</span> <span class="n">q_pos</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">current_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_q_marker_position</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">q_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Could not find q-marker for head movement&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1"># Get transition details</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
        <span class="n">new_q_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_found</span><span class="p">[</span><span class="s1">&#39;to_state&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current q-marker &#39;</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">&#39; at position </span><span class="si">{</span><span class="n">q_pos</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">q_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Moving </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">, new state: </span><span class="si">{</span><span class="n">new_q_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before move: </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="mi">60</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Delete old q-marker (always exactly 2 characters: q + digit)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">q_pos</span><span class="p">]</span>  <span class="c1"># Remove &#39;q&#39;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">q_pos</span><span class="p">]</span>  <span class="c1"># Remove digit (position shifts after first deletion)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After deleting q-marker: </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="mi">60</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Calculate new position based on direction</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
            <span class="c1"># Move left: The q-marker should be placed before the previous symbol</span>
            <span class="c1"># Since we deleted 2 characters, we need to account for that</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data_section_start</span><span class="p">(),</span> <span class="n">q_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Moving LEFT: inserting </span><span class="si">{</span><span class="n">new_q_state</span><span class="si">}</span><span class="s2"> at position </span><span class="si">{</span><span class="n">new_pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># direction == &#39;R&#39; </span>
            <span class="c1"># Move right: The q-marker should be placed after the current symbol</span>
            <span class="c1"># The symbol is now at position q_pos (since we deleted the q-marker)</span>
            <span class="c1"># We want to place the new q-marker after this symbol</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="n">q_pos</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># Extend tape if we&#39;re near the end</span>
            <span class="k">while</span> <span class="n">new_pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_q_state</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Moving RIGHT: inserting </span><span class="si">{</span><span class="n">new_q_state</span><span class="si">}</span><span class="s2"> at position </span><span class="si">{</span><span class="n">new_pos</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Insert new q-marker character by character</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_q_state</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_pos</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After inserting new q-marker: </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="mi">60</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Head moved </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">, new q-marker: </span><span class="si">{</span><span class="n">new_q_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;CONTINUE_SIMULATION&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_8_continue_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 8: Continue simulation by reading next symbol and transitioning to next meta-state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 8: Continuing simulation&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find new q-marker and symbol</span>
        <span class="n">q_state</span><span class="p">,</span> <span class="n">q_pos</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_q_marker_position</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">q_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_q_state</span> <span class="o">=</span> <span class="n">q_state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_symbol</span> <span class="o">=</span> <span class="n">symbol</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Next meta-state: (</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="c1"># Go back to find next transition</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;FIND_TRANSITION&#39;</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Lost q-marker during simulation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;HALT&#39;</span>
            <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">step_9_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step 9: Cleanup phase when halt state is reached</span>
<span class="sd">        Remove remaining q-marker from data section</span>
<span class="sd">        </span>
<span class="sd">        Q-markers are always exactly 2 characters: &#39;q&#39; + one digit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 9: Cleanup - removing final q-marker&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find and remove the last q-marker</span>
        <span class="n">q_state</span><span class="p">,</span> <span class="n">q_pos</span><span class="p">,</span> <span class="n">symbol_pos</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_q_marker_position</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">q_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove the q-marker (always 2 characters)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">q_pos</span><span class="p">]</span>  <span class="c1"># Remove &#39;q&#39;</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">q_pos</span><span class="p">]</span>  <span class="c1"># Remove digit (position shifts after first deletion)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed final q-marker &#39;</span><span class="si">{</span><span class="n">q_state</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final tape: </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[:</span><span class="mi">60</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;HALT&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">execute_single_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute one step of UTM simulation based on current state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation_steps</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_steps</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_steps</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum steps reached&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;HALT&#39;</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1"># State machine for UTM execution</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;START&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_1_start</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;FIND_INPUT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_2_find_input</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;INSERT_Q1&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_3_insert_q1</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;FIND_TRANSITION&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_4_find_transition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;MARK_TRANSITION&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_5_mark_transition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;WRITE_SYMBOL&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_6_write_symbol</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;MOVE_HEAD&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_7_move_head</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;CONTINUE_SIMULATION&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_8_continue_simulation</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;CLEANUP&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_9_cleanup</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;HALT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown state: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main simulation function - run the complete UTM simulation</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            encoded_tm: String encoding of the Turing machine to simulate</span>
<span class="sd">            input_string: Input data for the simulated machine</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Final tape contents (data section only)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">70</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UNIVERSAL TURING MACHINE SIMULATION&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">70</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: &#39;</span><span class="si">{</span><span class="n">input_string</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encoded TM: </span><span class="si">{</span><span class="n">encoded_tm</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_tape</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
        
        <span class="c1"># Run simulation loop</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s1">&#39;HALT&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_tape_state</span><span class="p">()</span>
            
            <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_single_step</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="c1"># Extract final result</span>
        <span class="n">data_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_section_start</span><span class="p">()</span>
        <span class="n">data_section</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLANK</span><span class="p">:</span>
                <span class="n">data_section</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="n">final_result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_section</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">70</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SIMULATION COMPLETE&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">70</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Steps taken: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_steps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final data section: &#39;</span><span class="si">{</span><span class="n">final_result</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UTM final state: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">final_result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_utm</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test the UTM with a simple example&quot;&quot;&quot;</span>
    
    <span class="c1"># Create a simple TM that flips bits: 0-&gt;1, 1-&gt;0</span>
    <span class="c1"># States: q1 (start), q2 (halt)</span>
    <span class="c1"># Transitions:</span>
    <span class="c1"># q1,0 -&gt; q1,1,R (flip 0 to 1, move right)</span>
    <span class="c1"># q1,1 -&gt; q1,0,R (flip 1 to 0, move right) </span>
    <span class="c1"># q1,Δ -&gt; q2,Δ,R (halt on blank)</span>
    
    <span class="n">encoded_tm</span> <span class="o">=</span> <span class="s2">&quot;q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R&quot;</span>
    <span class="n">input_string</span> <span class="o">=</span> <span class="s2">&quot;010&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Testing UTM with bit-flipping machine&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: </span><span class="si">{</span><span class="n">input_string</span><span class="si">}</span><span class="s2"> (expected output: 101)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Machine transitions:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,0 -&gt; q1,1,R (flip 0 to 1)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,1 -&gt; q1,0,R (flip 1 to 0)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,Δ -&gt; q2,Δ,R (halt)&quot;</span><span class="p">)</span>
    
    <span class="n">utm</span> <span class="o">=</span> <span class="n">UniversalTuringMachine</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">utm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected: 101&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test </span><span class="si">{</span><span class="s1">&#39;PASSED&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;101&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAILED&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_utm_simple</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test with an even simpler machine - just moves right and halts&quot;&quot;&quot;</span>
    
    <span class="c1"># Simple machine: read first symbol, move right, halt immediately</span>
    <span class="n">encoded_tm</span> <span class="o">=</span> <span class="s2">&quot;q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R&quot;</span>
    <span class="n">input_string</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing UTM with simple move-right-and-halt machine&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: </span><span class="si">{</span><span class="n">input_string</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Machine transitions:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,0 -&gt; q2,0,R (read 0, halt)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,1 -&gt; q2,1,R (read 1, halt)&quot;</span><span class="p">)</span> 
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,Δ -&gt; q2,Δ,R (read blank, halt)&quot;</span><span class="p">)</span>
    
    <span class="n">utm</span> <span class="o">=</span> <span class="n">UniversalTuringMachine</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">utm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Simple Test Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected: 1 (unchanged)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test </span><span class="si">{</span><span class="s1">&#39;PASSED&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAILED&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_utm_increment</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test with a binary increment machine&quot;&quot;&quot;</span>
    
    <span class="c1"># Binary incrementer: scan right to end, then increment from rightmost bit</span>
    <span class="c1"># q1: scan right, q2: halt, q3: increment (carry propagation)</span>
    <span class="n">encoded_tm</span> <span class="o">=</span> <span class="s2">&quot;q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R&quot;</span>
    <span class="n">input_string</span> <span class="o">=</span> <span class="s2">&quot;101&quot;</span>  <span class="c1"># 5 in binary, should become 110 (6 in binary)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing UTM with binary increment machine&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: </span><span class="si">{</span><span class="n">input_string</span><span class="si">}</span><span class="s2"> (5 in binary)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expected: 110 (6 in binary)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Machine transitions:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,0 -&gt; q1,0,R (scan right over 0)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,1 -&gt; q1,1,R (scan right over 1)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q1,Δ -&gt; q3,Δ,L (at end, start incrementing)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q3,0 -&gt; q2,1,R (0-&gt;1, done)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q3,1 -&gt; q3,0,L (1-&gt;0, carry left)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q3,Δ -&gt; q2,1,R (carry to new leftmost bit)&quot;</span><span class="p">)</span>
    
    <span class="n">utm</span> <span class="o">=</span> <span class="n">UniversalTuringMachine</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">utm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">encoded_tm</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Increment Test Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected: 110&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test </span><span class="si">{</span><span class="s1">&#39;PASSED&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;110&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAILED&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Run tests in order of complexity</span>
    <span class="n">test_utm_simple</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">test_utm</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> 
    <span class="n">test_utm_increment</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Testing UTM with simple move-right-and-halt machine
Input: 1
Machine transitions:
  q1,0 -&gt; q2,0,R (read 0, halt)
  q1,1 -&gt; q2,1,R (read 1, halt)
  q1,Δ -&gt; q2,Δ,R (read blank, halt)

======================================================================
UNIVERSAL TURING MACHINE SIMULATION
======================================================================
Input: &#39;1&#39;
Encoded TM: q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R...
Initializing UTM tape...
Encoded TM: q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R
Input string: 1

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 1: Starting UTM execution

============================================================
UTM State: FIND_INPUT
Step: 1
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 2: Finding input string start

============================================================
UTM State: INSERT_Q1
Step: 2
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 3: Inserting q1 marker
Inserted q1 marker, now reading symbol: 1

============================================================
UTM State: FIND_TRANSITION
Step: 3
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;1&#39; at pos 39
Step 4: Looking for transition (q1, 1)
Searching for transition: q1,1
In encoded section: q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R
Checking transition: q1,0 -&gt; q2,0,R
Checking transition: q1,1 -&gt; q2,1,R
✓ Found matching transition: q1,1,q2,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 4
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 1
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;1&#39;, &#39;to_state&#39;: &#39;q2&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 1}

============================================================
UTM State: WRITE_SYMBOL
Step: 5
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;1&#39; at pos 39
Replaced &#39;1&#39; with &#39;1&#39; at position 39
Tape after write: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ...

============================================================
UTM State: MOVE_HEAD
Step: 6
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;1&#39; at pos 39
Current q-marker &#39;q1&#39; at position 37-38
Moving R, new state: q2
Before move: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$q11ΔΔΔΔΔΔΔΔΔΔ...
After deleting q-marker: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ...
Moving RIGHT: inserting q2 at position 38
After inserting new q-marker: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1q2ΔΔΔΔΔΔΔΔΔΔ...
Head moved R, new q-marker: q2

============================================================
UTM State: CONTINUE_SIMULATION
Step: 7
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1q2ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q2&#39; at pos 38-39, symbol=&#39;Δ&#39; at pos 40
Next meta-state: (q2, Δ)

============================================================
UTM State: FIND_TRANSITION
Step: 8
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1q2ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q2
Simulated symbol: Δ
============================================================
Found q-marker: state=&#39;q2&#39; at pos 38-39, symbol=&#39;Δ&#39; at pos 40
Step 4: Looking for transition (q2, Δ)
Reached halt state q2

============================================================
UTM State: CLEANUP
Step: 9
Tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1q2ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q2
Simulated symbol: Δ
============================================================
Step 9: Cleanup - removing final q-marker
Found q-marker: state=&#39;q2&#39; at pos 38-39, symbol=&#39;Δ&#39; at pos 40
Removed final q-marker &#39;q2&#39;
Final tape: #q1,0,q2,0,R|q1,1,q2,1,R|q1,Δ,q2,Δ,R$1ΔΔΔΔΔΔΔΔΔΔ...

======================================================================
SIMULATION COMPLETE
======================================================================
Steps taken: 10
Final data section: &#39;1&#39;
UTM final state: HALT

Simple Test Result: 1
Expected: 1 (unchanged)
Test PASSED

================================================================================

Testing UTM with bit-flipping machine
Input: 010 (expected output: 101)
Machine transitions:
  q1,0 -&gt; q1,1,R (flip 0 to 1)
  q1,1 -&gt; q1,0,R (flip 1 to 0)
  q1,Δ -&gt; q2,Δ,R (halt)

======================================================================
UNIVERSAL TURING MACHINE SIMULATION
======================================================================
Input: &#39;010&#39;
Encoded TM: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R...
Initializing UTM tape...
Encoded TM: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R
Input string: 010

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$010ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$010ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 1: Starting UTM execution

============================================================
UTM State: FIND_INPUT
Step: 1
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$010ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 2: Finding input string start

============================================================
UTM State: INSERT_Q1
Step: 2
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$010ΔΔΔΔΔΔΔΔΔΔ
                                           ^
Head position: 37
============================================================
Step 3: Inserting q1 marker
Inserted q1 marker, now reading symbol: 0

============================================================
UTM State: FIND_TRANSITION
Step: 3
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1010ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;0&#39; at pos 39
Step 4: Looking for transition (q1, 0)
Searching for transition: q1,0
In encoded section: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R
Checking transition: q1,0 -&gt; q1,1,R
✓ Found matching transition: q1,0,q1,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 4
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1010ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 0
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;0&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 0}

============================================================
UTM State: WRITE_SYMBOL
Step: 5
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1010ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;0&#39; at pos 39
Replaced &#39;0&#39; with &#39;1&#39; at position 39
Tape after write: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1110ΔΔΔΔΔΔΔΔ...

============================================================
UTM State: MOVE_HEAD
Step: 6
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1110ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 37-38, symbol=&#39;1&#39; at pos 39
Current q-marker &#39;q1&#39; at position 37-38
Moving R, new state: q1
Before move: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$q1110ΔΔΔΔΔΔΔΔΔΔ...
After deleting q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$110ΔΔΔΔΔΔΔΔΔΔ...
Moving RIGHT: inserting q1 at position 38
After inserting new q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q110ΔΔΔΔΔΔΔΔΔΔ...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 7
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q110ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 38-39, symbol=&#39;1&#39; at pos 40
Next meta-state: (q1, 1)

============================================================
UTM State: FIND_TRANSITION
Step: 8
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q110ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Found q-marker: state=&#39;q1&#39; at pos 38-39, symbol=&#39;1&#39; at pos 40
Step 4: Looking for transition (q1, 1)
Searching for transition: q1,1
In encoded section: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R
Checking transition: q1,0 -&gt; q1,1,R
Checking transition: q1,1 -&gt; q1,0,R
✓ Found matching transition: q1,1,q1,0,R

============================================================
UTM State: MARK_TRANSITION
Step: 9
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q110ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 1
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;1&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;0&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 1}

============================================================
UTM State: WRITE_SYMBOL
Step: 10
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q110ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 38-39, symbol=&#39;1&#39; at pos 40
Replaced &#39;1&#39; with &#39;0&#39; at position 40
Tape after write: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q100ΔΔΔΔΔΔΔΔ...

============================================================
UTM State: MOVE_HEAD
Step: 11
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q100ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 38-39, symbol=&#39;0&#39; at pos 40
Current q-marker &#39;q1&#39; at position 38-39
Moving R, new state: q1
Before move: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$1q100ΔΔΔΔΔΔΔΔΔΔ...
After deleting q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$100ΔΔΔΔΔΔΔΔΔΔ...
Moving RIGHT: inserting q1 at position 39
After inserting new q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q10ΔΔΔΔΔΔΔΔΔΔ...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 12
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q10ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 39-40, symbol=&#39;0&#39; at pos 41
Next meta-state: (q1, 0)

============================================================
UTM State: FIND_TRANSITION
Step: 13
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q10ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Found q-marker: state=&#39;q1&#39; at pos 39-40, symbol=&#39;0&#39; at pos 41
Step 4: Looking for transition (q1, 0)
Searching for transition: q1,0
In encoded section: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R
Checking transition: q1,0 -&gt; q1,1,R
✓ Found matching transition: q1,0,q1,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 14
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q10ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 0
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;0&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 0}

============================================================
UTM State: WRITE_SYMBOL
Step: 15
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q10ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 39-40, symbol=&#39;0&#39; at pos 41
Replaced &#39;0&#39; with &#39;1&#39; at position 41
Tape after write: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q11ΔΔΔΔΔΔΔΔ...

============================================================
UTM State: MOVE_HEAD
Step: 16
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q11ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 39-40, symbol=&#39;1&#39; at pos 41
Current q-marker &#39;q1&#39; at position 39-40
Moving R, new state: q1
Before move: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$10q11ΔΔΔΔΔΔΔΔΔΔ...
After deleting q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101ΔΔΔΔΔΔΔΔΔΔ...
Moving RIGHT: inserting q1 at position 40
After inserting new q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 17
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 40-41, symbol=&#39;Δ&#39; at pos 42
Next meta-state: (q1, Δ)

============================================================
UTM State: FIND_TRANSITION
Step: 18
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Found q-marker: state=&#39;q1&#39; at pos 40-41, symbol=&#39;Δ&#39; at pos 42
Step 4: Looking for transition (q1, Δ)
Searching for transition: q1,Δ
In encoded section: q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R
Checking transition: q1,0 -&gt; q1,1,R
Checking transition: q1,1 -&gt; q1,0,R
Checking transition: q1,Δ -&gt; q2,Δ,R
✓ Found matching transition: q1,Δ,q2,Δ,R

============================================================
UTM State: MARK_TRANSITION
Step: 19
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 2
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;Δ&#39;, &#39;to_state&#39;: &#39;q2&#39;, &#39;write_symbol&#39;: &#39;Δ&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 2}

============================================================
UTM State: WRITE_SYMBOL
Step: 20
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 40-41, symbol=&#39;Δ&#39; at pos 42
Replaced &#39;Δ&#39; with &#39;Δ&#39; at position 42
Tape after write: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔ...

============================================================
UTM State: MOVE_HEAD
Step: 21
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 40-41, symbol=&#39;Δ&#39; at pos 42
Current q-marker &#39;q1&#39; at position 40-41
Moving R, new state: q2
Before move: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101q1ΔΔΔΔΔΔΔΔΔΔ...
After deleting q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101ΔΔΔΔΔΔΔΔΔΔ...
Moving RIGHT: inserting q2 at position 41
After inserting new q-marker: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101Δq2ΔΔΔΔΔΔΔΔΔ...
Head moved R, new q-marker: q2

============================================================
UTM State: CONTINUE_SIMULATION
Step: 22
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101Δq2ΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q2&#39; at pos 41-42, symbol=&#39;Δ&#39; at pos 43
Next meta-state: (q2, Δ)

============================================================
UTM State: FIND_TRANSITION
Step: 23
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101Δq2ΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q2
Simulated symbol: Δ
============================================================
Found q-marker: state=&#39;q2&#39; at pos 41-42, symbol=&#39;Δ&#39; at pos 43
Step 4: Looking for transition (q2, Δ)
Reached halt state q2

============================================================
UTM State: CLEANUP
Step: 24
Tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101Δq2ΔΔΔΔΔΔΔΔΔ
                                             ^
Head position: 39
Simulated machine state: q2
Simulated symbol: Δ
============================================================
Step 9: Cleanup - removing final q-marker
Found q-marker: state=&#39;q2&#39; at pos 41-42, symbol=&#39;Δ&#39; at pos 43
Removed final q-marker &#39;q2&#39;
Final tape: #q1,0,q1,1,R|q1,1,q1,0,R|q1,Δ,q2,Δ,R$101ΔΔΔΔΔΔΔΔΔΔ...

======================================================================
SIMULATION COMPLETE
======================================================================
Steps taken: 25
Final data section: &#39;101&#39;
UTM final state: HALT

Test Result: 101
Expected: 101
Test PASSED

================================================================================


Testing UTM with binary increment machine
Input: 101 (5 in binary)
Expected: 110 (6 in binary)
Machine transitions:
  q1,0 -&gt; q1,0,R (scan right over 0)
  q1,1 -&gt; q1,1,R (scan right over 1)
  q1,Δ -&gt; q3,Δ,L (at end, start incrementing)
  q3,0 -&gt; q2,1,R (0-&gt;1, done)
  q3,1 -&gt; q3,0,L (1-&gt;0, carry left)
  q3,Δ -&gt; q2,1,R (carry to new leftmost bit)

======================================================================
UNIVERSAL TURING MACHINE SIMULATION
======================================================================
Input: &#39;101&#39;
Encoded TM: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3...
Initializing UTM tape...
Encoded TM: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Input string: 101

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101ΔΔΔΔ
                                                                               ^
Head position: 73
============================================================

============================================================
UTM State: START
Step: 0
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101ΔΔΔΔ
                                                                               ^
Head position: 73
============================================================
Step 1: Starting UTM execution

============================================================
UTM State: FIND_INPUT
Step: 1
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101ΔΔΔΔ
                                                                               ^
Head position: 73
============================================================
Step 2: Finding input string start

============================================================
UTM State: INSERT_Q1
Step: 2
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101ΔΔΔΔ
                                                                               ^
Head position: 73
============================================================
Step 3: Inserting q1 marker
Inserted q1 marker, now reading symbol: 1

============================================================
UTM State: FIND_TRANSITION
Step: 3
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$q1101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Found q-marker: state=&#39;q1&#39; at pos 73-74, symbol=&#39;1&#39; at pos 75
Step 4: Looking for transition (q1, 1)
Searching for transition: q1,1
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
Checking transition: q1,1 -&gt; q1,1,R
✓ Found matching transition: q1,1,q1,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 4
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$q1101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 1
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;1&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 1}

============================================================
UTM State: WRITE_SYMBOL
Step: 5
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$q1101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 73-74, symbol=&#39;1&#39; at pos 75
Replaced &#39;1&#39; with &#39;1&#39; at position 75
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 6
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$q1101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 73-74, symbol=&#39;1&#39; at pos 75
Current q-marker &#39;q1&#39; at position 73-74
Moving R, new state: q1
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving RIGHT: inserting q1 at position 74
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 7
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Next meta-state: (q1, 0)

============================================================
UTM State: FIND_TRANSITION
Step: 8
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 0
============================================================
Found q-marker: state=&#39;q1&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Step 4: Looking for transition (q1, 0)
Searching for transition: q1,0
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
✓ Found matching transition: q1,0,q1,0,R

============================================================
UTM State: MARK_TRANSITION
Step: 9
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 0
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;0&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;0&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 0}

============================================================
UTM State: WRITE_SYMBOL
Step: 10
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Replaced &#39;0&#39; with &#39;0&#39; at position 76
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 11
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q101ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Current q-marker &#39;q1&#39; at position 74-75
Moving R, new state: q1
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving RIGHT: inserting q1 at position 75
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 12
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q11ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 0
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Next meta-state: (q1, 1)

============================================================
UTM State: FIND_TRANSITION
Step: 13
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q11ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Found q-marker: state=&#39;q1&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Step 4: Looking for transition (q1, 1)
Searching for transition: q1,1
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
Checking transition: q1,1 -&gt; q1,1,R
✓ Found matching transition: q1,1,q1,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 14
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q11ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 1
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;1&#39;, &#39;to_state&#39;: &#39;q1&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 1}

============================================================
UTM State: WRITE_SYMBOL
Step: 15
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q11ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Replaced &#39;1&#39; with &#39;1&#39; at position 77
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 16
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q11ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Current q-marker &#39;q1&#39; at position 75-76
Moving R, new state: q1
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving RIGHT: inserting q1 at position 76
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved R, new q-marker: q1

============================================================
UTM State: CONTINUE_SIMULATION
Step: 17
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101q1ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: 1
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q1&#39; at pos 76-77, symbol=&#39;Δ&#39; at pos 78
Next meta-state: (q1, Δ)

============================================================
UTM State: FIND_TRANSITION
Step: 18
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101q1ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Found q-marker: state=&#39;q1&#39; at pos 76-77, symbol=&#39;Δ&#39; at pos 78
Step 4: Looking for transition (q1, Δ)
Searching for transition: q1,Δ
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
Checking transition: q1,1 -&gt; q1,1,R
Checking transition: q1,Δ -&gt; q3,Δ,L
✓ Found matching transition: q1,Δ,q3,Δ,L

============================================================
UTM State: MARK_TRANSITION
Step: 19
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101q1ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 2
Transition details: {&#39;from_state&#39;: &#39;q1&#39;, &#39;read_symbol&#39;: &#39;Δ&#39;, &#39;to_state&#39;: &#39;q3&#39;, &#39;write_symbol&#39;: &#39;Δ&#39;, &#39;direction&#39;: &#39;L&#39;, &#39;transition_index&#39;: 2}

============================================================
UTM State: WRITE_SYMBOL
Step: 20
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101q1ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q1&#39; at pos 76-77, symbol=&#39;Δ&#39; at pos 78
Replaced &#39;Δ&#39; with &#39;Δ&#39; at position 78
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 21
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$101q1ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q1&#39; at pos 76-77, symbol=&#39;Δ&#39; at pos 78
Current q-marker &#39;q1&#39; at position 76-77
Moving L, new state: q3
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving LEFT: inserting q3 at position 75
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved L, new q-marker: q3

============================================================
UTM State: CONTINUE_SIMULATION
Step: 22
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q31ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q1
Simulated symbol: Δ
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q3&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Next meta-state: (q3, 1)

============================================================
UTM State: FIND_TRANSITION
Step: 23
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q31ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 1
============================================================
Found q-marker: state=&#39;q3&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Step 4: Looking for transition (q3, 1)
Searching for transition: q3,1
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
Checking transition: q1,1 -&gt; q1,1,R
Checking transition: q1,Δ -&gt; q3,Δ,L
Checking transition: q3,0 -&gt; q2,1,R
Checking transition: q3,1 -&gt; q3,0,L
✓ Found matching transition: q3,1,q3,0,L

============================================================
UTM State: MARK_TRANSITION
Step: 24
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q31ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 1
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 4
Transition details: {&#39;from_state&#39;: &#39;q3&#39;, &#39;read_symbol&#39;: &#39;1&#39;, &#39;to_state&#39;: &#39;q3&#39;, &#39;write_symbol&#39;: &#39;0&#39;, &#39;direction&#39;: &#39;L&#39;, &#39;transition_index&#39;: 4}

============================================================
UTM State: WRITE_SYMBOL
Step: 25
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q31ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 1
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q3&#39; at pos 75-76, symbol=&#39;1&#39; at pos 77
Replaced &#39;1&#39; with &#39;0&#39; at position 77
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 26
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$10q30ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 1
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q3&#39; at pos 75-76, symbol=&#39;0&#39; at pos 77
Current q-marker &#39;q3&#39; at position 75-76
Moving L, new state: q3
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving LEFT: inserting q3 at position 74
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved L, new q-marker: q3

============================================================
UTM State: CONTINUE_SIMULATION
Step: 27
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q300ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 1
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q3&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Next meta-state: (q3, 0)

============================================================
UTM State: FIND_TRANSITION
Step: 28
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q300ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 0
============================================================
Found q-marker: state=&#39;q3&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Step 4: Looking for transition (q3, 0)
Searching for transition: q3,0
In encoded section: q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R
Checking transition: q1,0 -&gt; q1,0,R
Checking transition: q1,1 -&gt; q1,1,R
Checking transition: q1,Δ -&gt; q3,Δ,L
Checking transition: q3,0 -&gt; q2,1,R
✓ Found matching transition: q3,0,q2,1,R

============================================================
UTM State: MARK_TRANSITION
Step: 29
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q300ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 0
============================================================
Step 5: Marking transition (blue marker)
Marked transition at index 3
Transition details: {&#39;from_state&#39;: &#39;q3&#39;, &#39;read_symbol&#39;: &#39;0&#39;, &#39;to_state&#39;: &#39;q2&#39;, &#39;write_symbol&#39;: &#39;1&#39;, &#39;direction&#39;: &#39;R&#39;, &#39;transition_index&#39;: 3}

============================================================
UTM State: WRITE_SYMBOL
Step: 30
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q300ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 0
============================================================
Step 6: Writing new symbol to simulated tape
Found q-marker: state=&#39;q3&#39; at pos 74-75, symbol=&#39;0&#39; at pos 76
Replaced &#39;0&#39; with &#39;1&#39; at position 76
Tape after write: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q...

============================================================
UTM State: MOVE_HEAD
Step: 31
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$1q310ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 0
============================================================
Step 7: Moving simulated machine head
Found q-marker: state=&#39;q3&#39; at pos 74-75, symbol=&#39;1&#39; at pos 76
Current q-marker &#39;q3&#39; at position 74-75
Moving R, new state: q2
Before move: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
After deleting q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Moving RIGHT: inserting q2 at position 75
After inserting new q-marker: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...
Head moved R, new q-marker: q2

============================================================
UTM State: CONTINUE_SIMULATION
Step: 32
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$11q20ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q3
Simulated symbol: 0
============================================================
Step 8: Continuing simulation
Found q-marker: state=&#39;q2&#39; at pos 75-76, symbol=&#39;0&#39; at pos 77
Next meta-state: (q2, 0)

============================================================
UTM State: FIND_TRANSITION
Step: 33
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$11q20ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q2
Simulated symbol: 0
============================================================
Found q-marker: state=&#39;q2&#39; at pos 75-76, symbol=&#39;0&#39; at pos 77
Step 4: Looking for transition (q2, 0)
Reached halt state q2

============================================================
UTM State: CLEANUP
Step: 34
Tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L|q3,Δ,q2,1,R$11q20ΔΔ
                                                                                 ^
Head position: 75
Simulated machine state: q2
Simulated symbol: 0
============================================================
Step 9: Cleanup - removing final q-marker
Found q-marker: state=&#39;q2&#39; at pos 75-76, symbol=&#39;0&#39; at pos 77
Removed final q-marker &#39;q2&#39;
Final tape: #q1,0,q1,0,R|q1,1,q1,1,R|q1,Δ,q3,Δ,L|q3,0,q2,1,R|q3,1,q3,0,L...

======================================================================
SIMULATION COMPLETE
======================================================================
Steps taken: 35
Final data section: &#39;110&#39;
UTM final state: HALT

Increment Test Result: 110
Expected: 110
Test PASSED
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="the-halting-problem">
<h2>3. The Halting Problem<a class="headerlink" href="#the-halting-problem" title="Link to this heading">#</a></h2>
<p>After introducing the Universal Turing Machine (UTM), a machine capable of simulating any other Turing machine on any input, we encounter a natural yet profound question: can the UTM determine whether the simulated machine will eventually halt or run forever? This leads us to the Halting Problem, one of the most important undecidable problems in computer science. It asks: “Given a description of a Turing machine <span class="math notranslate nohighlight">\(T\)</span> and an input <span class="math notranslate nohighlight">\(w\)</span>, will <span class="math notranslate nohighlight">\(T\)</span> eventually halt on input <span class="math notranslate nohighlight">\(w\)</span>, or will it run forever?” This seemingly simple question leads to profound insights about the fundamental limits of computation.</p>
<section id="the-halting-problem-is-undecidable">
<h3>3.1 The Halting Problem is Undecidable<a class="headerlink" href="#the-halting-problem-is-undecidable" title="Link to this heading">#</a></h3>
<p>Alan Turing proved in 1936 that there is no Turing machine that can solve this problem for all inputs. That is, there is no general algorithm that can determine whether an arbitrary program will halt on a given input.</p>
<p>To prove it, assume there is a machine <span class="math notranslate nohighlight">\(H\)</span> that solves the Halting Problem. Then we build a paradoxical machine <span class="math notranslate nohighlight">\(M\)</span> that uses <span class="math notranslate nohighlight">\(H\)</span> but behaves in the opposite way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Let</span> <span class="n">H</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">T</span> <span class="n">halts</span> <span class="n">on</span> <span class="n">w</span><span class="p">,</span> <span class="kc">False</span> <span class="n">otherwise</span><span class="o">.</span>

<span class="n">Define</span> <span class="n">M</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">H</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>     <span class="c1"># Check if T halts on its own description</span>
        <span class="n">loop</span> <span class="n">forever</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;done&#39;</span>
</pre></div>
</div>
<p>Now ask: what happens if we run <span class="math notranslate nohighlight">\(M\)</span> on itself, <span class="math notranslate nohighlight">\(M(M)\)</span>?</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(H(M, M) returns True, M(M)\)</span> enters infinite loop, but this contradicts <span class="math notranslate nohighlight">\(H\)</span> returning True.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(H(M, M) returns False, M(M)\)</span> returns ‘done’ and halts, but this contradicts <span class="math notranslate nohighlight">\(H\)</span> returning False.</p></li>
</ul>
<p>Conclusion: Such a machine <span class="math notranslate nohighlight">\(H\)</span> cannot exist. The Halting Problem is undecidable.</p>
</section>
<section id="the-collatz-conjecture-and-halting-behavior">
<h3>3.2 The Collatz Conjecture and Halting Behavior<a class="headerlink" href="#the-collatz-conjecture-and-halting-behavior" title="Link to this heading">#</a></h3>
<p>The Collatz Conjecture is a famous unsolved problem in mathematics. It defines a sequence based on a very simple rule:</p>
<p>Given any positive integer <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(n\)</span> is even, divide it by 2: <span class="math notranslate nohighlight">\(n \rightarrow n/2\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\(n\)</span> is odd, multiply by 3 and add 1: <span class="math notranslate nohighlight">\(n \rightarrow 3n + 1\)</span></p></li>
</ul>
<p>Repeat the process with the new value of <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p><strong>The Conjecture Says</strong>: No matter what positive integer you start with, the sequence will eventually reach 1.</p>
<p>This has been tested for billions of numbers, and every time the sequence eventually hits 1. But no one has ever proven this is true for all positive integers. This is a perfect example of a program where we don’t know if it always halts for every positive input. But we can’t prove that it doesn’t halt either. This makes it a “natural” analog to the Halting Problem.</p>
<p>If someone could prove (or disprove) the Collatz Conjecture, they would either show that the function always halts (conjecture is true), or provide a counterexample where it loops forever (conjecture is false). But right now we don’t know whether collatz(n) halts for all <span class="math notranslate nohighlight">\(n\)</span>. Until we prove the Collatz Conjecture (or disprove it), we cannot write a program that can guarantee correct answers about whether the Collatz sequence halts for all inputs. That’s why it’s often used as an example of the difficulty in determining halting behavior, even for very simple-looking rules.</p>
<p>As of the time this document was generated, the Collatz Conjecture remains an open problem with unknown decidability status: it is not yet known whether the conjecture is decidable or undecidable.</p>
</section>
<section id="the-utm-and-the-halting-problem">
<h3>3.3 The UTM and the Halting Problem<a class="headerlink" href="#the-utm-and-the-halting-problem" title="Link to this heading">#</a></h3>
<p>You might wonder why a Universal Turing Machine (UTM) can’t solve the Halting Problem. Although a UTM can simulate a Turing machine <span class="math notranslate nohighlight">\(T\)</span> on input <span class="math notranslate nohighlight">\(w\)</span>, deciding whether <span class="math notranslate nohighlight">\(T\)</span> will halt requires knowing in advance if the simulation will ever stop. However, since the Halting Problem is undecidable, the UTM has no general way to make that determination. It could end up simulating <span class="math notranslate nohighlight">\(T\)</span> forever, without ever reaching a conclusion about whether it should halt.</p>
<p>You might think: “Just run <span class="math notranslate nohighlight">\(T\)</span> on <span class="math notranslate nohighlight">\(w\)</span> using the UTM. If it halts, we know it halts!” But the problem is: What if <span class="math notranslate nohighlight">\(T\)</span> never halts? The UTM will simulate <span class="math notranslate nohighlight">\(T\)</span> forever, never returning an answer. So the UTM does not decide HALT because a decider must always halt with a correct “yes” or “no” answer. Think of the UTM as a powerful but blind simulator: It can run any program, but it can’t peek into the future. It can’t tell if a program will loop forever unless it actually does (and possibly loops forever itself trying).</p>
</section>
<section id="practical-implications">
<h3>3.4 Practical Implications<a class="headerlink" href="#practical-implications" title="Link to this heading">#</a></h3>
<p>The Halting Problem is more than a theoretical curiosity, it has far-reaching consequences for how we write, analyze, and reason about software and computation. Below are several real-world domains where the undecidability of the Halting Problem directly limits what can be achieved with algorithms and automation.</p>
<section id="software-verification">
<h4>3.4.1 Software Verification<a class="headerlink" href="#software-verification" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Can we automatically prove that a program is completely free of bugs or unintended behavior?</p></li>
<li><p>Limitation: Due to the Halting Problem, we know that fully automating the verification of all possible behaviors of arbitrary programs is impossible. For example, we cannot always tell if a program will get stuck in an infinite loop, access invalid memory, or violate a specification.</p></li>
<li><p>Workaround: Developers and researchers use approximation techniques like model checking, static analysis, or type systems. These can catch many bugs, but they often sacrifice completeness or soundness. Formal methods are used for high-assurance systems, but they are expensive and applicable only in constrained domains.</p></li>
</ul>
</section>
<section id="compiler-optimization">
<h4>3.4.2 Compiler Optimization<a class="headerlink" href="#compiler-optimization" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Can a compiler automatically determine whether applying a certain optimization will preserve the behavior of the original program?</p></li>
<li><p>Limitation: Deciding whether two versions of a program are equivalent (e.g., before and after optimization) is undecidable in general, since this is closely related to the Halting Problem and program equivalence.</p></li>
<li><p>Workaround: Compilers apply conservative analysis. They only apply optimizations when they are provably safe under limited assumptions. Techniques like profile-guided optimization or interprocedural analysis improve performance, but may miss some opportunities to avoid the risk of incorrect transformations.</p></li>
</ul>
</section>
<section id="malware-detection">
<h4>3.4.3 Malware Detection<a class="headerlink" href="#malware-detection" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Is it possible to build a system that can detect all malicious software automatically?</p></li>
<li><p>Limitation: The Halting Problem implies that perfect malware detection is impossible. Deciding whether a given binary behaves maliciously (e.g., deletes files, exfiltrates data) in all cases is a semantic property of the program, and is therefore undecidable (see Rice’s Theorem below).</p></li>
<li><p>Workaround: Modern anti-malware systems rely on heuristics, sandbox execution, behavioral monitoring, and machine learning. These methods can be evaded and produce false positives or negatives because they cannot make guaranteed decisions for all programs.</p></li>
</ul>
</section>
<section id="program-equivalence">
<h4>3.4.4 Program Equivalence<a class="headerlink" href="#program-equivalence" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Do two programs compute exactly the same function on all inputs?</p></li>
<li><p>Limitation: In general, this is undecidable. It’s equivalent to asking whether two arbitrary Turing machines halt and produce the same result on all inputs. This directly follows from the Halting Problem.</p></li>
<li><p>Workaround: Developers rely on testing, symbolic execution, or formal equivalence checking in restricted settings, such as when programs are expressed in constrained functional languages or finite domains.</p></li>
</ul>
</section>
<section id="resource-usage">
<h4>3.4.5 Resource Usage<a class="headerlink" href="#resource-usage" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Can we determine in advance whether a program will use finite memory or terminate within a time limit?</p></li>
<li><p>Limitation: Determining exact time or space bounds for arbitrary programs is also undecidable. It is a generalization of the Halting Problem to quantitative properties.</p></li>
<li><p>Workaround: Static analysis tools attempt to approximate worst-case behavior. Runtime monitoring and timeouts are commonly used to manage unbounded resource consumption in production systems, especially when running untrusted code (e.g., in sandboxed environments).</p></li>
</ul>
</section>
<section id="verification-of-ai-safety">
<h4>3.4.6 Verification of AI Safety<a class="headerlink" href="#verification-of-ai-safety" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Problem: Can we formally prove an AI agent will always behave safely?</p></li>
<li><p>Undecidability Insight: In reinforcement learning or planning, agents take actions in open-ended environments. Determining whether an agent will avoid all unsafe states (e.g., harming users or the environment) is often equivalent to verifying an arbitrary program will avoid certain behaviors, which is undecidable in general.</p></li>
<li><p>Workaround: Constrain action spaces and environment dynamics; Use reward shaping and safe exploration techniques; Design agents with fallback mechanisms or fail-safe states</p></li>
</ul>
</section>
</section>
<section id="id3">
<h3>3.5 Example Python Implementation<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HaltingExamples</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collection of programs demonstrating halting and non-halting behavior&quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">examples</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">simple_halting_programs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Examples of programs that clearly halt&quot;&quot;&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PROGRAMS THAT CLEARLY HALT:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>
        
        <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Counter Program&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def count_to_n(n):</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        print(i)</span>
<span class="s2">    return &#39;done&#39;</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Halts after exactly n iterations&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Factorial Calculator&quot;</span><span class="p">,</span> 
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def factorial(n):</span>
<span class="s2">    if n &lt;= 1:</span>
<span class="s2">        return 1</span>
<span class="s2">    return n * factorial(n-1)</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Halts after n recursive calls (assuming n &gt;= 0)&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Array Search&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def linear_search(arr, target):</span>
<span class="s2">    for i, item in enumerate(arr):</span>
<span class="s2">        if item == target:</span>
<span class="s2">            return i</span>
<span class="s2">    return -1</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Always halts after at most len(arr) iterations&quot;</span>
            <span class="p">}</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;• </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Code: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Analysis: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;analysis&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">simple_non_halting_programs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Examples of programs that clearly don&#39;t halt&quot;&quot;&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PROGRAMS THAT CLEARLY DON&#39;T HALT:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span>
        
        <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Infinite Loop&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def infinite_loop():</span>
<span class="s2">    while True:</span>
<span class="s2">        print(&quot;Running forever...&quot;)</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Never terminates - obvious infinite loop&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Infinite Recursion&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def infinite_recursion(x):</span>
<span class="s2">    return infinite_recursion(x + 1)</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Recurses forever, never reaches base case&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Server Loop&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def web_server():</span>
<span class="s2">    while True:</span>
<span class="s2">        request = get_request()</span>
<span class="s2">        process_request(request)</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Designed to run forever (intentional non-halting)&quot;</span>
            <span class="p">}</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;• </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Code: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Analysis: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;analysis&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">ambiguous_halting_programs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Examples where halting behavior is unclear or depends on unsolved problems&quot;&quot;&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PROGRAMS WITH UNCLEAR HALTING BEHAVIOR:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">45</span><span class="p">)</span>
        
        <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Collatz Conjecture&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def collatz(n):</span>
<span class="s2">    while n != 1:</span>
<span class="s2">        if n % 2 == 0:</span>
<span class="s2">            n = n // 2</span>
<span class="s2">        else:</span>
<span class="s2">            n = 3 * n + 1</span>
<span class="s2">    return &#39;reached 1&#39;</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Conjectured to halt for all positive integers, but unproven!&quot;</span><span class="p">,</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;Open mathematical problem&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Prime Search&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def find_odd_perfect_number():</span>
<span class="s2">    n = 3</span>
<span class="s2">    while True:</span>
<span class="s2">        if is_perfect(n) and n % 2 == 1:</span>
<span class="s2">            return n</span>
<span class="s2">        n += 2</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Halts if odd perfect numbers exist, unknown in mathematics&quot;</span><span class="p">,</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;Depends on unsolved number theory problem&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Goldbach Search&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def goldbach_counterexample():</span>
<span class="s2">    n = 4</span>
<span class="s2">    while True:</span>
<span class="s2">        if not can_express_as_sum_of_two_primes(n):</span>
<span class="s2">            return n</span>
<span class="s2">        n += 2</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Halts if Goldbach conjecture is false, likely never halts&quot;</span><span class="p">,</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;Depends on Goldbach conjecture (unproven but likely true)&quot;</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Busy Beaver&quot;</span><span class="p">,</span>
                <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def busy_beaver_n(n):</span>
<span class="s2">    max_steps = 0</span>
<span class="s2">    # Search through all n-state Turing machines</span>
<span class="s2">    for tm in all_n_state_turing_machines(n):</span>
<span class="s2">        steps = simulate_until_halt(tm)</span>
<span class="s2">        if steps &gt; max_steps:</span>
<span class="s2">            max_steps = steps</span>
<span class="s2">    return max_steps</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analysis&quot;</span><span class="p">:</span> <span class="s2">&quot;Halts for any fixed n, but BB(n) grows faster than any computable function&quot;</span><span class="p">,</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;Computable but not efficiently computable&quot;</span>
            <span class="p">}</span>
        <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;• </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Code: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Analysis: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;analysis&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Status: </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

<span class="c1"># Demonstrate the examples</span>
<span class="n">examples</span> <span class="o">=</span> <span class="n">HaltingExamples</span><span class="p">()</span>
<span class="n">examples</span><span class="o">.</span><span class="n">simple_halting_programs</span><span class="p">()</span>
<span class="n">examples</span><span class="o">.</span><span class="n">simple_non_halting_programs</span><span class="p">()</span> 
<span class="n">examples</span><span class="o">.</span><span class="n">ambiguous_halting_programs</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PROGRAMS THAT CLEARLY HALT:
===================================
• Counter Program:
  Code: def count_to_n(n):
    for i in range(n):
        print(i)
    return &#39;done&#39;
  Analysis: Halts after exactly n iterations

• Factorial Calculator:
  Code: def factorial(n):
    if n &lt;= 1:
        return 1
    return n * factorial(n-1)
  Analysis: Halts after n recursive calls (assuming n &gt;= 0)

• Array Search:
  Code: def linear_search(arr, target):
    for i, item in enumerate(arr):
        if item == target:
            return i
    return -1
  Analysis: Always halts after at most len(arr) iterations

PROGRAMS THAT CLEARLY DON&#39;T HALT:
========================================
• Infinite Loop:
  Code: def infinite_loop():
    while True:
        print(&quot;Running forever...&quot;)
  Analysis: Never terminates - obvious infinite loop

• Infinite Recursion:
  Code: def infinite_recursion(x):
    return infinite_recursion(x + 1)
  Analysis: Recurses forever, never reaches base case

• Server Loop:
  Code: def web_server():
    while True:
        request = get_request()
        process_request(request)
  Analysis: Designed to run forever (intentional non-halting)

PROGRAMS WITH UNCLEAR HALTING BEHAVIOR:
=============================================
• Collatz Conjecture:
  Code: def collatz(n):
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return &#39;reached 1&#39;
  Analysis: Conjectured to halt for all positive integers, but unproven!
  Status: Open mathematical problem

• Prime Search:
  Code: def find_odd_perfect_number():
    n = 3
    while True:
        if is_perfect(n) and n % 2 == 1:
            return n
        n += 2
  Analysis: Halts if odd perfect numbers exist, unknown in mathematics
  Status: Depends on unsolved number theory problem

• Goldbach Search:
  Code: def goldbach_counterexample():
    n = 4
    while True:
        if not can_express_as_sum_of_two_primes(n):
            return n
        n += 2
  Analysis: Halts if Goldbach conjecture is false, likely never halts
  Status: Depends on Goldbach conjecture (unproven but likely true)

• Busy Beaver:
  Code: def busy_beaver_n(n):
    max_steps = 0
    # Search through all n-state Turing machines
    for tm in all_n_state_turing_machines(n):
        steps = simulate_until_halt(tm)
        if steps &gt; max_steps:
            max_steps = steps
    return max_steps
  Analysis: Halts for any fixed n, but BB(n) grows faster than any computable function
  Status: Computable but not efficiently computable
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="other-undecidable-problems">
<h2>4. Other Undecidable Problems<a class="headerlink" href="#other-undecidable-problems" title="Link to this heading">#</a></h2>
<p>The Halting Problem is the most famous undecidable problem, but it’s part of a larger family of problems for which no algorithmic solution can exist. Many of these are reducible to the Halting Problem, and vice versa.</p>
<section id="rices-theorem">
<h3>4.1 Rice’s Theorem<a class="headerlink" href="#rices-theorem" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Statement: Any non-trivial semantic property of a program (i.e., any property that depends on what the program does, not just its syntax) is undecidable.</p></li>
<li><p>Examples:</p>
<ul>
<li><p>Does a program always output a prime number?</p></li>
<li><p>Is the function total (i.e., does it halt on all inputs)?</p></li>
<li><p>Will the program ever print “Hello”?</p></li>
</ul>
</li>
<li><p>Significance: This theorem generalizes the Halting Problem and shows that most interesting questions about program behavior are undecidable, no matter how simple they seem.</p></li>
</ul>
</section>
<section id="post-correspondence-problem-pcp">
<h3>4.2 Post Correspondence Problem (PCP)<a class="headerlink" href="#post-correspondence-problem-pcp" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Statement: Given a set of domino tiles, each with a top and bottom string, can you arrange them to make the top and bottom sequences match exactly?</p></li>
<li><p>Example: Tiles: [ab/aba], [b/bb], [a/b] Can you find a sequence (with repeats) that makes the top and bottom equal?</p></li>
<li><p>Significance: PCP is a classic example of a simple-to-state but undecidable problem. It’s widely used in reductions to prove undecidability in formal language theory.</p></li>
</ul>
</section>
<section id="tiling-problem">
<h3>4.3 Tiling Problem<a class="headerlink" href="#tiling-problem" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Statement: Given a finite set of square tiles with colored edges, can they tile the infinite plane without mismatches?</p></li>
<li><p>Examples: Wang tiles, Penrose tilings</p></li>
<li><p>Significance: This problem connects computation to geometry, showing that undecidability appears in spatial problems too. It demonstrates that even physical-looking problems can encode the Halting Problem.</p></li>
</ul>
</section>
</section>
<section id="practice-exercises">
<h2>5. Practice Exercises<a class="headerlink" href="#practice-exercises" title="Link to this heading">#</a></h2>
<section id="exercise-1">
<h3>5.1 Exercise 1:<a class="headerlink" href="#exercise-1" title="Link to this heading">#</a></h3>
<p>Try answering the following questions (true or false):</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Statement</p></th>
<th class="head"><p>T/F</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Every program that halts can be detected by a Universal Turing Machine.</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>The Halting Problem is solvable for specific programs.</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>Rice’s Theorem only applies to syntax-based properties.</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>You can always tell if two Python functions do the same thing.</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>The Collatz Conjecture is proven to always halt.</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="exercise-2">
<h3>5.2 Exercise 2:<a class="headerlink" href="#exercise-2" title="Link to this heading">#</a></h3>
<p>Write a short reflection on: “What does the Halting Problem tell us about the role of humans in programming, debugging, or creating intelligent systems? Can intuition or creativity overcome limits that machines cannot?”</p>
</section>
<section id="exercise-3-rices-theorem-in-action">
<h3>5.3 Exercise 3: Rice’s Theorem in Action<a class="headerlink" href="#exercise-3-rices-theorem-in-action" title="Link to this heading">#</a></h3>
<p>For each of the following program properties, determine whether it is decidable or undecidable using Rice’s Theorem.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Program Property</p></th>
<th class="head"><p>Decidable or Undecidable?</p></th>
<th class="head"><p>Why?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Does the program contain the word “print”?</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>Does the program halt on input 5?</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>Does the program always return True?</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>Does the program use less than 1MB of RAM?</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>Does the program ever output “Hello, World!”?</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="exercise-4-try-a-reduction-argument">
<h3>5.4 Exercise 4: Try a Reduction Argument<a class="headerlink" href="#exercise-4-try-a-reduction-argument" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Goal: Can you outline how to reduce HALT to this problem, showing that it’s at least as hard as the Halting Problem?</p></li>
<li><p>Problem: Suppose we define the problem: “Given a Turing machine M, does it ever print the symbol ‘#’ when run on blank input?”</p></li>
<li><p>Hints:</p>
<ul>
<li><p>Construct a machine <span class="math notranslate nohighlight">\(M\)</span> that prints <span class="math notranslate nohighlight">\(\#\)</span> if and only if <span class="math notranslate nohighlight">\(M\)</span> halts.</p></li>
<li><p>Then solving this new problem would solve HALT, which is impossible.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="further-reading">
<h2>6. Further Reading<a class="headerlink" href="#further-reading" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>“Introduction to the Theory of Computation” by Michael Sipser, Chapter 4, 5, 6</p></li>
<li><p>“Introduction to Computer Theory” by Daniel I.A. Cohen, Chapter 23</p></li>
<li><p>“Automata Theory, Languages, and Computation” by Hopcroft, Motwani, and Ullman, Chapter 9</p></li>
<li><p>“The Annotated Turing: A Guided Tour Through Alan Turing’s Historic Paper on Computability and the Turing Machine” by Charles Petzold</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./content - backup\Part_3_Turing_Machines\Chapter_16"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turing-machine-subprograms-insert-and-delete">1. Turing Machine Subprograms: insert and delete</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-challenge-of-insert-and-delete">1.1 The Challenge of Insert and Delete</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#insert">1.2 Insert</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#delete">1.3 Delete</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-python-implementation">1.4 Example Python Implementation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">2. The Universal Turing Machine</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definition-of-the-universal-turing-machine">2.1 Definition of The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-study-the-universal-turing-machine">2.2 Why Study The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-world-applications-of-the-universal-turing-machine">2.3 Real-World Applications of The Universal Turing Machine</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-the-utm-exists">2.4 Why the UTM Exists</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-to-construct-the-utm">2.5 How to Construct the UTM</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1-design-the-encoding-scheme">2.5.1 Step 1: Design the Encoding Scheme</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2-design-the-utm-s-tape-layout">2.5.2 Step 2: Design the UTM’s Tape Layout</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3-design-the-utm-s-state-structure">2.5.3 Step 3: Design the UTM’s State Structure</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">2.5.4 Example Python Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-halting-problem">3. The Halting Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-halting-problem-is-undecidable">3.1 The Halting Problem is Undecidable</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-collatz-conjecture-and-halting-behavior">3.2 The Collatz Conjecture and Halting Behavior</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-utm-and-the-halting-problem">3.3 The UTM and the Halting Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implications">3.4 Practical Implications</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#software-verification">3.4.1 Software Verification</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#compiler-optimization">3.4.2 Compiler Optimization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#malware-detection">3.4.3 Malware Detection</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#program-equivalence">3.4.4 Program Equivalence</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#resource-usage">3.4.5 Resource Usage</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#verification-of-ai-safety">3.4.6 Verification of AI Safety</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">3.5 Example Python Implementation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-undecidable-problems">4. Other Undecidable Problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rices-theorem">4.1 Rice’s Theorem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#post-correspondence-problem-pcp">4.2 Post Correspondence Problem (PCP)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tiling-problem">4.3 Tiling Problem</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-exercises">5. Practice Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1">5.1 Exercise 1:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2">5.2 Exercise 2:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-rices-theorem-in-action">5.3 Exercise 3: Rice’s Theorem in Action</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-try-a-reduction-argument">5.4 Exercise 4: Try a Reduction Argument</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">6. Further Reading</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Yong Zhang, Dylan Zwick
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>